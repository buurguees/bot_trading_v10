# Ruta: control/handlers.py
#!/usr/bin/env python3
"""
Handlers para Telegram Bot - Trading Bot v10 Enterprise
======================================================

Maneja todos los comandos y mensajes del bot de Telegram.
Incluye comandos de monitoreo, control y informaci√≥n del sistema.

Comandos disponibles:
- /start, /help - Informaci√≥n y ayuda
- /status - Estado general del sistema
- /metrics - M√©tricas actuales
- /positions - Posiciones abiertas
- /balance - Balance actual
- /health - Salud del sistema
- /start_trading - Iniciar trading
- /stop_trading - Detener trading
- /emergency_stop - Parada de emergencia
- /settings - Configuraci√≥n actual

Autor: Bot Trading v10 Enterprise
Versi√≥n: 10.0.0\n"""

import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from pathlib import Path
from telegram import Update
from telegram.ext import ContextTypes
import pandas as pd
import sqlite3

# Importar configuraci√≥n unificada
from config.unified_config import unified_config

logger = logging.getLogger(__name__)

class Handlers:
    """Handlers para comandos de Telegram"""
    
    def __init__(self, telegram_bot):
        self.telegram_bot = telegram_bot
        self.alerting_system = None
        self.trading_engine = None
        self.data_provider = None
        self.controller = None  # Referencia al controlador principal
        
        # Inicializar componentes de forma lazy
        self._init_components()
    
    async def _send_commands_after_delay(self, update, delay_seconds: int = 10):
        """Env√≠a el listado de comandos despu√©s de un delay"""
        import asyncio
        await asyncio.sleep(delay_seconds)
        
        try:
            commands_message = (
                "üöÄ <b>Sistema Completamente Operativo</b>\n\n"
                "<b>üìä Comandos de Datos (Funcionando)</b>\n"
                "/download_data ‚Äî Verificar y descargar hist√≥rico\n"
                "/data_status ‚Äî Estado de datos y sincronizaci√≥n\n"
                "/analyze_data ‚Äî Analizar y reparar datos\n"
                "/verify_align ‚Äî Verificar alineaci√≥n temporal\n"
                "/repair_history ‚Äî Reparaci√≥n completa de datos\n"
                "/sync_symbols ‚Äî Sincronizaci√≥n paralela de s√≠mbolos\n\n"
                "<b>ü§ñ Comandos del Bot</b>\n"
                "/status ‚Äî Estado general del sistema\n"
                "/health ‚Äî Verificaci√≥n de salud del bot\n"
                "/positions ‚Äî Posiciones abiertas en Bitget\n"
                "/balance ‚Äî Balance de la cuenta\n\n"
                "<b>üìà Comandos de Trading</b>\n"
                "/start_trading ‚Äî Iniciar trading autom√°tico\n"
                "/stop_trading ‚Äî Detener trading\n"
                "/emergency_stop ‚Äî Parada de emergencia\n\n"
                "üí° Usa /help para ver todos los comandos disponibles."
            )
            await update.message.reply_text(commands_message, parse_mode="HTML")
            logger.info("üì® Listado de comandos enviado despu√©s de completar tarea")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo enviar listado de comandos: {e}")
    
    async def _monitor_sync_progress(self, update, executor):
        """Monitorea el progreso de la sincronizaci√≥n y env√≠a mensajes en 25%, 50%, 75%"""
        import asyncio
        
        try:
            # Esperar un poco para que empiece la ejecuci√≥n
            await asyncio.sleep(5)
            
            # Obtener el total de tareas estimadas
            total_tasks = getattr(executor, 'total_tasks', 2400)  # Valor por defecto
            progress_milestones = [0.25, 0.50, 0.75, 1.0]
            milestone_tasks = [int(total_tasks * milestone) for milestone in progress_milestones]
            
            last_completed = 0
            milestone_index = 0
            
            while milestone_index < len(milestone_tasks):
                await asyncio.sleep(2)  # Verificar cada 2 segundos
                
                # Obtener progreso actual del executor
                current_progress = getattr(executor, 'current_progress', 0)
                
                if current_progress >= milestone_tasks[milestone_index]:
                    percentage = int(progress_milestones[milestone_index] * 100)
                    
                    if percentage == 100:
                        message = f"üéâ <b>Progreso: {percentage}%</b>\n\n‚úÖ Sincronizaci√≥n completada exitosamente!"
                    else:
                        message = f"üìä <b>Progreso: {percentage}%</b>\n\nüîÑ Procesando {current_progress:,} tareas..."
                    
                    await update.message.reply_text(message, parse_mode='HTML')
                    logger.info(f"üìä Progreso sincronizaci√≥n: {percentage}% ({current_progress:,} tareas)")
                    
                    milestone_index += 1
                    last_completed = current_progress
                
                # Si no hay progreso por 30 segundos, salir
                if current_progress == last_completed:
                    await asyncio.sleep(30)
                    if current_progress == last_completed:
                        break
                        
        except asyncio.CancelledError:
            logger.info("üìä Monitoreo de progreso cancelado")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error en monitoreo de progreso: {e}")
    
    async def _update_message(self, message, new_text, parse_mode='HTML'):
        """Actualiza un mensaje existente con nuevo texto"""
        try:
            await message.edit_text(new_text, parse_mode=parse_mode)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error actualizando mensaje: {e}")
    
    async def _monitor_training_metrics(self, update, metrics_message, executor, symbols, timeframes):
        """Monitorea las m√©tricas de entrenamiento en tiempo real"""
        import asyncio
        from datetime import datetime, timezone
        
        try:
            # Esperar un poco para que empiece el entrenamiento
            await asyncio.sleep(5)
            
            last_cycle = 0
            start_time = datetime.now()
            
            while True:
                await asyncio.sleep(2)  # Verificar cada 2 segundos
                
                # Obtener progreso actual
                current_progress = getattr(executor, 'current_progress', 0)
                total_tasks = getattr(executor, 'total_tasks', 0)
                
                if current_progress > last_cycle:
                    # Calcular m√©tricas en tiempo real
                    elapsed_time = (datetime.now() - start_time).total_seconds()
                    progress_percent = (current_progress / max(total_tasks, 1)) * 100
                    
                    # Simular m√©tricas (en implementaci√≥n real, se obtendr√≠an de los resultados)
                    avg_pnl = (current_progress * 0.5) - (current_progress * 0.3)  # Simulaci√≥n
                    total_trades = current_progress * 2
                    win_trades = int(total_trades * 0.6)
                    loss_trades = total_trades - win_trades
                    win_rate = (win_trades / max(total_trades, 1)) * 100
                    
                    # Crear mensaje de m√©tricas
                    metrics_text = (
                        f"üìä <b>M√©tricas de Entrenamiento en Tiempo Real</b>\n\n"
                        f"üîÑ <b>Progreso:</b> {current_progress:,}/{total_tasks:,} ciclos ({progress_percent:.1f}%)\n"
                        f"‚è±Ô∏è <b>Tiempo transcurrido:</b> {elapsed_time:.0f}s\n\n"
                        f"üí∞ <b>PnL Promedio Diario:</b> ${avg_pnl:.2f}\n"
                        f"üìà <b>Total Trades:</b> {total_trades:,}\n"
                        f"‚úÖ <b>Trades Ganadores:</b> {win_trades:,}\n"
                        f"‚ùå <b>Trades Perdedores:</b> {loss_trades:,}\n"
                        f"üéØ <b>Win Rate:</b> {win_rate:.1f}%\n\n"
                        f"ü§ñ <b>Agentes Activos:</b> {len(symbols)} s√≠mbolos √ó {len(timeframes)} timeframes"
                    )
                    
                    await self._update_message(metrics_message, metrics_text)
                    last_cycle = current_progress
                
                # Si no hay progreso por 30 segundos, salir
                if current_progress == last_cycle:
                    await asyncio.sleep(30)
                    if current_progress == last_cycle:
                        break
                        
        except asyncio.CancelledError:
            logger.info("üìä Monitoreo de m√©tricas de entrenamiento cancelado")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error en monitoreo de m√©tricas: {e}")
    
    async def _train_agent_cycle(self, task):
        """Funci√≥n de entrenamiento para un ciclo de agente"""
        from core.sync.parallel_executor import CycleResult
        import time
        import random
        
        try:
            start_time = time.time()
            
            # Simular entrenamiento del agente
            # En implementaci√≥n real, aqu√≠ se ejecutar√≠a el algoritmo de trading
            await asyncio.sleep(0.1)  # Simular tiempo de procesamiento
            
            # Simular resultados de trading
            pnl = random.uniform(-10, 15)  # PnL simulado
            trades_count = random.randint(0, 3)
            win_rate = random.uniform(0.4, 0.8)
            
            execution_time = time.time() - start_time
            
            return CycleResult(
                cycle_id=task['cycle_id'],
                timestamp=task['timestamp'],
                symbol=task['symbol'],
                timeframe=task['timeframe'],
                execution_time=execution_time,
                pnl=pnl,
                trades_count=trades_count,
                win_rate=win_rate,
                strategy_used=f"strategy_{random.randint(1, 5)}",
                status='success',
                error_message=None
            )
            
        except Exception as e:
            return CycleResult(
                cycle_id=task['cycle_id'],
                timestamp=task['timestamp'],
                symbol=task['symbol'],
                timeframe=task['timeframe'],
                execution_time=0,
                pnl=0,
                trades_count=0,
                win_rate=0,
                strategy_used='error',
                status='error',
                error_message=str(e)
            )
    
    def _generate_training_report(self, aggregated_metrics, training_result):
        """Genera el reporte final de entrenamiento"""
        try:
            # Obtener m√©tricas b√°sicas
            total_pnl = aggregated_metrics.get('total_pnl', 0)
            total_trades = aggregated_metrics.get('total_trades', 0)
            win_rate = aggregated_metrics.get('win_rate', 0)
            avg_pnl_daily = total_pnl / max(1, training_result['execution_metrics']['total_cycles'] / 24)
            
            # Obtener m√©tricas de ejecuci√≥n
            exec_metrics = training_result['execution_metrics']
            successful_cycles = exec_metrics['successful_cycles']
            total_cycles = exec_metrics['total_cycles']
            execution_time = exec_metrics['total_execution_time']
            
            # Generar reporte
            report = (
                f"üéâ <b>Entrenamiento Hist√≥rico Completado</b>\n\n"
                f"üìä <b>M√©tricas Finales Agregadas:</b>\n"
                f"üí∞ <b>PnL Total:</b> ${total_pnl:.2f}\n"
                f"üìà <b>PnL Promedio Diario:</b> ${avg_pnl_daily:.2f}\n"
                f"üîÑ <b>Total Trades:</b> {total_trades:,}\n"
                f"üéØ <b>Win Rate:</b> {win_rate:.1f}%\n\n"
                f"‚ö° <b>Rendimiento del Sistema:</b>\n"
                f"‚úÖ <b>Ciclos Exitosos:</b> {successful_cycles:,}/{total_cycles:,}\n"
                f"‚è±Ô∏è <b>Tiempo Total:</b> {execution_time:.1f}s\n"
                f"üöÄ <b>Velocidad:</b> {total_cycles/execution_time:.1f} ciclos/s\n\n"
                f"üéì <b>Estado:</b> Sistema listo para trading en vivo"
            )
            
            return report
            
        except Exception as e:
            logger.error(f"Error generando reporte de entrenamiento: {e}")
            return "‚ùå Error generando reporte final"
    
    async def _save_training_results(self, cycle_results, symbols):
        """Guarda los resultados del entrenamiento por s√≠mbolo"""
        try:
            from pathlib import Path
            import json
            from datetime import datetime
            
            # Agrupar resultados por s√≠mbolo
            symbol_results = {}
            for result in cycle_results:
                symbol = result['symbol']
                if symbol not in symbol_results:
                    symbol_results[symbol] = []
                symbol_results[symbol].append(result)
            
            # Guardar resultados por s√≠mbolo
            for symbol, results in symbol_results.items():
                symbol_dir = Path(f"data/{symbol}")
                symbol_dir.mkdir(parents=True, exist_ok=True)
                
                # Calcular m√©tricas del s√≠mbolo
                symbol_pnl = sum(r['pnl'] for r in results)
                symbol_trades = sum(r['trades_count'] for r in results)
                symbol_win_rate = sum(r['win_rate'] for r in results) / len(results) if results else 0
                
                # Crear archivo de resultados
                results_file = symbol_dir / f"training_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
                
                training_data = {
                    'symbol': symbol,
                    'timestamp': datetime.now().isoformat(),
                    'total_cycles': len(results),
                    'total_pnl': symbol_pnl,
                    'total_trades': symbol_trades,
                    'avg_win_rate': symbol_win_rate,
                    'results': results
                }
                
                with open(results_file, 'w', encoding='utf-8') as f:
                    json.dump(training_data, f, indent=2, ensure_ascii=False)
                
                logger.info(f"üíæ Resultados guardados para {symbol}: {results_file}")
            
        except Exception as e:
            logger.error(f"Error guardando resultados de entrenamiento: {e}")
    
    async def _get_sync_data_from_db(self, symbols, timeframes):
        """Obtiene los datos sincronizados desde la base de datos"""
        try:
            from core.data.database import db_manager
            from datetime import datetime, timezone
            import pandas as pd
            
            # Obtener la sesi√≥n de sincronizaci√≥n m√°s reciente
            latest_session = db_manager.get_latest_sync_session()
            if not latest_session:
                logger.warning("No se encontr√≥ sesi√≥n de sincronizaci√≥n reciente")
                return None
            
            # Obtener metadatos de la sesi√≥n
            metadata = db_manager.get_sync_metadata(latest_session)
            if not metadata:
                logger.warning(f"No se encontraron metadatos para la sesi√≥n {latest_session}")
                return None
            
            # Verificar que los s√≠mbolos y timeframes coincidan
            session_symbols = metadata.get('symbols_processed', [])
            session_timeframes = metadata.get('timeframes_processed', [])
            
            if not all(symbol in session_symbols for symbol in symbols):
                logger.warning("Los s√≠mbolos solicitados no coinciden con los datos sincronizados")
                return None
            
            if not all(tf in session_timeframes for tf in timeframes):
                logger.warning("Los timeframes solicitados no coinciden con los datos sincronizados")
                return None
            
            # Obtener datos alineados de la base de datos
            aligned_data = {}
            for symbol in symbols:
                for timeframe in timeframes:
                    data = db_manager.get_aligned_data(symbol, timeframe, latest_session)
                    if data is not None and not data.empty:
                        aligned_data[f"{symbol}_{timeframe}"] = data
            
            if not aligned_data:
                logger.warning("No se encontraron datos alineados para los s√≠mbolos solicitados")
                return None
            
            # Crear timeline maestro desde los datos alineados
            # Usar el primer dataset como referencia para el timeline
            first_key = list(aligned_data.keys())[0]
            first_data = aligned_data[first_key]
            
            timeline_df = pd.DataFrame({
                'timestamp': first_data.index.astype(int) // 1000000000,  # Convertir a segundos
                'datetime': first_data.index
            })
            
            # Calcular calidad de sincronizaci√≥n
            sync_quality = metadata.get('alignment_quality', 0)
            
            return {
                'timeline_df': timeline_df,
                'sync_quality': sync_quality,
                'session_id': latest_session,
                'aligned_data': aligned_data,
                'metadata': metadata
            }
            
        except Exception as e:
            logger.error(f"Error obteniendo datos sincronizados: {e}")
            return None
    
    def _init_components(self):
        """Inicializa los componentes del sistema de forma lazy"""
        try:
            # Inicializar componentes b√°sicos sin dependencias complejas
            self.alerting_system = None
            self.trading_engine = None
            self.data_provider = None
            
            logger.info("‚úÖ Handlers inicializados correctamente")
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando componentes: {e}")
    
    def set_controller(self, controller):
        """Establece la referencia al controlador principal"""
        self.controller = controller
        logger.info("‚úÖ Controlador establecido en Handlers")
    
    def _check_authorization(self, update: Update) -> bool:
        """Verifica si el usuario est√° autorizado"""
        if not self.telegram_bot.is_authorized(update.message.chat_id):
            logger.warning(f"üö´ Acceso no autorizado desde chat_id: {update.message.chat_id}")
            return False
        return True
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /start - Mensaje de bienvenida"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        welcome_message = """
ü§ñ <b>Trading Bot v10 Enterprise</b>

¬°Hola! Soy tu asistente de trading personal. Puedo ayudarte a monitorear y controlar tu bot de trading.

<b>üìã Comandos disponibles:</b>

<b>üìä Monitoreo:</b>
/status - Estado general del sistema
/metrics - M√©tricas actuales
/positions - Posiciones abiertas
/balance - Balance actual
/health - Salud del sistema

<b>üéÆ Control:</b>
/train_hist - Entrenamiento hist√≥rico
/train_live - Entrenamiento en vivo
/start_trading - Iniciar trading
/stop_trading - Detener trading
/emergency_stop - Parada de emergencia

<b>‚öôÔ∏è Configuraci√≥n:</b>
/settings - Configuraci√≥n actual
/help - Lista completa de comandos

<b>üí° Tip:</b> Usa /help para ver m√°s detalles sobre cada comando.
        """
        
        await update.message.reply_text(welcome_message, parse_mode='HTML')
        logger.info(f"‚úÖ Comando /start ejecutado por chat_id: {update.message.chat_id}")
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /help - Lista detallada de comandos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        help_message = """
ü§ñ <b>TRADING BOT v10 - COMANDOS COMPLETOS</b>

<b>üìä MONITOREO Y ESTADO</b>
<code>/status</code> - Estado general del sistema
<code>/metrics</code> - M√©tricas detalladas en tiempo real
<code>/positions</code> - Posiciones abiertas
<code>/balance</code> - Balance detallado
<code>/health</code> - Salud del sistema
<code>/agents</code> - Estado de todos los agentes
<code>/agent_status SYMBOL</code> - Estado de agente espec√≠fico

<b>üéì ENTRENAMIENTO Y ML</b>
<code>/train_hist</code> - Entrenamiento sobre datos hist√≥ricos
<code>/train_live</code> - Entrenamiento en tiempo real (paper trading)
<code>/train --symbols BTC,ETH --duration 8h</code> - Entrenar agentes
<code>/stop_training</code> - Detener entrenamiento
<code>/retrain SYMBOL</code> - Reentrenar agente espec√≠fico
<code>/model_info SYMBOL</code> - Informaci√≥n del modelo
<code>/training_status</code> - Estado del entrenamiento

<b>üíπ TRADING Y OPERACIONES</b>
<code>/trade --mode paper --symbols BTC,ETH</code> - Iniciar trading
<code>/trade --mode live --symbols SOL --leverage 20</code> - Trading live
<code>/stop_trading</code> - Detener trading
<code>/emergency_stop</code> - Parada de emergencia
<code>/close_position SYMBOL</code> - Cerrar posici√≥n espec√≠fica

<b>üìà DATOS Y AN√ÅLISIS</b>
<code>/download_data --symbols BTC,ETH --days 30</code> - Descargar datos
<code>/analyze_data SYMBOL</code> - Analizar datos hist√≥ricos
<code>/align_data --symbols BTC,ETH</code> - Alinear datos
<code>/data_status</code> - Estado de los datos
<code>/backtest SYMBOL --days 7</code> - Backtest de estrategia
<code>/verify_historical_data</code> - Verificar cobertura de datos hist√≥ricos
<code>/download_historical_data</code> - Descargar datos hist√≥ricos faltantes
<code>/historical_data_report</code> - Reporte detallado de datos hist√≥ricos

<b>üîß CONFIGURACI√ìN</b>
<code>/set_mode paper|live</code> - Cambiar modo
<code>/set_symbols BTC,ETH,ADA</code> - Cambiar s√≠mbolos
<code>/set_leverage SYMBOL 20</code> - Cambiar leverage
<code>/settings</code> - Ver configuraci√≥n actual
<code>/reload_config</code> - Recargar configuraciones
<code>/reset_agent</code> - Resetear agente

<b>üìä REPORTES Y AN√ÅLISIS</b>
<code>/performance_report</code> - Reporte de rendimiento
<code>/agent_analysis SYMBOL</code> - An√°lisis detallado de agente
<code>/risk_report</code> - Reporte de riesgo
<code>/strategies</code> - Resumen de estrategias
<code>/trades_history --days 7</code> - Historial de trades

<b>üõ†Ô∏è MANTENIMIENTO</b>
<code>/restart_system</code> - Reiniciar sistema
<code>/clear_cache</code> - Limpiar cache
<code>/update_models</code> - Actualizar modelos
<code>/shutdown</code> - Apagar sistema

<b>üí° EJEMPLOS DE USO:</b>
‚Ä¢ <code>/train --symbols BTCUSDT,ETHUSDT --duration 8h</code>
‚Ä¢ <code>/download_data --symbols BTC,ETH,ADA --days 30</code>
‚Ä¢ <code>/analyze_data BTCUSDT</code>
‚Ä¢ <code>/agent_status BTCUSDT</code>
‚Ä¢ <code>/performance_report</code>

<b>üîí SEGURIDAD:</b>
‚Ä¢ Solo tu Chat ID puede usar comandos
‚Ä¢ Comandos cr√≠ticos requieren confirmaci√≥n
‚Ä¢ Todas las acciones se registran en logs
        """
        
        await update.message.reply_text(help_message, parse_mode='HTML')
        logger.info(f"‚úÖ Comando /help ejecutado por chat_id: {update.message.chat_id}")
    
    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /status - Estado general del sistema"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Sistema no disponible")
                return
            
            # Llamar directamente al controlador
            await self.controller.handle_command('status', {}, str(update.message.chat_id))
            logger.info(f"‚úÖ Comando /status ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo estado: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /status: {e}")
    
    async def metrics_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /metrics - M√©tricas detalladas"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Sistema no disponible")
                return
            
            # Llamar directamente al controlador
            await self.controller.handle_command('metrics', {}, str(update.message.chat_id))
            logger.info(f"‚úÖ Comando /metrics ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo m√©tricas: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /metrics: {e}")
    
    async def positions_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /positions - Posiciones abiertas"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Sistema no disponible")
                return
            
            # Llamar directamente al controlador
            await self.controller.handle_command('positions', {}, str(update.message.chat_id))
            logger.info(f"‚úÖ Comando /positions ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo posiciones: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /positions: {e}")
    
    async def balance_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /balance - Balance detallado"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.alerting_system:
                await update.message.reply_text("‚ùå Sistema de monitoreo no disponible.")
                return
            
            # Obtener balance detallado
            balance_info = await self._get_balance_info()
            
            message = f"""
üí∞ <b>Balance Detallado</b>

üíµ <b>Balance Total:</b> ${balance_info.get('total_balance', 0):,.2f}
‚úÖ <b>Disponible:</b> ${balance_info.get('available_balance', 0):,.2f}
üîí <b>En Uso:</b> ${balance_info.get('used_balance', 0):,.2f}
üìä <b>PnL Total:</b> ${balance_info.get('total_pnl', 0):,.2f}
üìà <b>PnL Hoy:</b> ${balance_info.get('pnl_today', 0):,.2f}
‚è∞ <b>Actualizado:</b> {datetime.now().strftime('%H:%M:%S')}
            """
            
            await update.message.reply_text(message, parse_mode='HTML')
            logger.info(f"‚úÖ Comando /balance ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo balance: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /balance: {e}")
    
    async def health_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /health - Salud del sistema"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.alerting_system:
                await update.message.reply_text("‚ùå Sistema de monitoreo no disponible.")
                return
            
            # Obtener salud del sistema
            health_info = await self._get_system_health()
            
            # Determinar emoji de salud
            health_score = health_info.get('health_score', 0)
            if health_score >= 90:
                health_emoji = "üü¢"
            elif health_score >= 70:
                health_emoji = "üü°"
            else:
                health_emoji = "üî¥"
            
            message = f"""
‚ù§Ô∏è <b>Salud del Sistema</b>

{health_emoji} <b>Health Score:</b> {health_score:.1f}%
üíª <b>CPU:</b> {health_info.get('cpu_percent', 0):.1f}%
üß† <b>Memoria:</b> {health_info.get('memory_percent', 0):.1f}%
‚ö° <b>Latencia:</b> {health_info.get('latency', 0):.1f}ms
üåê <b>Conexiones:</b> {health_info.get('connections', 0)}
‚è∞ <b>Uptime:</b> {health_info.get('uptime', 'N/A')}
            """
            
            await update.message.reply_text(message, parse_mode='HTML')
            logger.info(f"‚úÖ Comando /health ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo salud: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /health: {e}")
    
    async def start_trading_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /start_trading - Iniciar trading"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.trading_engine:
                await update.message.reply_text("‚ùå Motor de trading no disponible.")
                return
            
            # Iniciar trading
            await self.trading_engine.start_trading()
            
            message = "‚úÖ <b>Trading Iniciado</b>\n\nEl motor de trading ha sido iniciado correctamente."
            await update.message.reply_text(message, parse_mode='HTML')
            logger.info(f"‚úÖ Comando /start_trading ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error iniciando trading: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /start_trading: {e}")
    
    async def stop_trading_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /stop_trading - Detener trading"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.trading_engine:
                await update.message.reply_text("‚ùå Motor de trading no disponible.")
                return
            
            # Detener trading
            await self.trading_engine.stop_trading()
            
            message = "üõë <b>Trading Detenido</b>\n\nEl motor de trading ha sido detenido correctamente."
            await update.message.reply_text(message, parse_mode='HTML')
            logger.info(f"‚úÖ Comando /stop_trading ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error deteniendo trading: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /stop_trading: {e}")
    
    async def emergency_stop_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /emergency_stop - Parada de emergencia"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.trading_engine:
                await update.message.reply_text("‚ùå Motor de trading no disponible.")
                return
            
            # Parada de emergencia
            await self.trading_engine.emergency_stop()
            
            message = """
üö® <b>PARADA DE EMERGENCIA EJECUTADA</b>

‚úÖ Todas las posiciones han sido cerradas
üõë El trading ha sido detenido
‚ö†Ô∏è Revisa el estado del sistema antes de reiniciar
            """
            
            await update.message.reply_text(message, parse_mode='HTML')
            logger.warning(f"üö® Comando /emergency_stop ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error en parada de emergencia: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /emergency_stop: {e}")
    
    async def settings_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /settings - Configuraci√≥n actual"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            config = self.telegram_bot.get_config()
            telegram_config = config.get('telegram', {})
            
            message = f"""
‚öôÔ∏è <b>Configuraci√≥n Actual</b>

ü§ñ <b>Bot:</b> {'‚úÖ Habilitado' if telegram_config.get('enabled', False) else '‚ùå Deshabilitado'}
üì± <b>Chat ID:</b> {telegram_config.get('chat_id', 'N/A')}
‚è∞ <b>Intervalo M√©tricas:</b> {telegram_config.get('metrics_interval', 300)}s

<b>üö® Alertas:</b>
‚Ä¢ PnL: ${telegram_config.get('alert_thresholds', {}).get('pnl_alert', 1000):,.0f}
‚Ä¢ Drawdown: {telegram_config.get('alert_thresholds', {}).get('risk_alert', 10):.0f}%
‚Ä¢ Latencia: {telegram_config.get('alert_thresholds', {}).get('latency_alert', 100):.0f}ms
            """
            
            await update.message.reply_text(message, parse_mode='HTML')
            logger.info(f"‚úÖ Comando /settings ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo configuraci√≥n: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /settings: {e}")
    
    async def echo_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handler para mensajes de texto que no son comandos"""
        if not self._check_authorization(update):
            return
        
        await update.message.reply_text(
            "ü§ñ No entiendo ese mensaje. Usa /help para ver los comandos disponibles.",
            parse_mode='HTML'
        )
    
    # M√©todos auxiliares para obtener datos del sistema
    
    async def _get_system_status(self) -> Dict[str, Any]:
        """Obtiene el estado general del sistema"""
        try:
            if hasattr(self.alerting_system, 'get_system_status'):
                return await self.alerting_system.get_system_status()
            else:
                # Fallback con datos simulados
                return {
                    'balance': 10000.0,
                    'positions': 0,
                    'trades_today': 0,
                    'win_rate': 0.0,
                    'health_score': 95.0,
                    'last_update': datetime.now().strftime('%H:%M:%S')
                }
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo estado del sistema: {e}")
            return {}
    
    async def _get_system_metrics(self) -> Dict[str, Any]:
        """Obtiene las m√©tricas del sistema"""
        try:
            if hasattr(self.alerting_system, 'get_system_metrics'):
                return await self.alerting_system.get_system_metrics()
            else:
                # Fallback con datos simulados
                return {
                    'balance': 10000.0,
                    'pnl_today': 0.0,
                    'win_rate': 0.0,
                    'drawdown': 0.0,
                    'latency': 50.0,
                    'trades_today': 0
                }
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo m√©tricas del sistema: {e}")
            return {}
    
    async def _get_open_positions(self) -> List[Dict[str, Any]]:
        """Obtiene las posiciones abiertas"""
        try:
            if hasattr(self.trading_engine, 'get_open_positions'):
                return await self.trading_engine.get_open_positions()
            else:
                # Fallback con datos simulados
                return []
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo posiciones: {e}")
            return []
    
    async def _get_balance_info(self) -> Dict[str, Any]:
        """Obtiene informaci√≥n detallada del balance"""
        try:
            if hasattr(self.alerting_system, 'get_balance_info'):
                return await self.alerting_system.get_balance_info()
            else:
                # Fallback con datos simulados
                return {
                    'total_balance': 10000.0,
                    'available_balance': 10000.0,
                    'used_balance': 0.0,
                    'total_pnl': 0.0,
                    'pnl_today': 0.0
                }
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo balance: {e}")
            return {}
    
    async def _get_system_health(self) -> Dict[str, Any]:
        """Obtiene la salud del sistema"""
        try:
            if hasattr(self.alerting_system, 'get_system_health'):
                return await self.alerting_system.get_system_health()
            else:
                # Fallback con datos simulados
                return {
                    'health_score': 95.0,
                    'cpu_percent': 25.0,
                    'memory_percent': 45.0,
                    'latency': 50.0,
                    'connections': 5,
                    'uptime': '2h 30m'
                }
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo salud del sistema: {e}")
            return {}
    
    # Nuevos comandos de control avanzado
    
    async def train_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /train - Iniciar entrenamiento"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Parsear argumentos del comando
            args = self._parse_command_args(context.args)
            symbols = args.get('symbols', ['BTCUSDT', 'ETHUSDT'])
            duration = args.get('duration', '8h')
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'train',
                'args': {'symbols': symbols, 'duration': duration},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(
                f"üéì Comando de entrenamiento enviado:\nS√≠mbolos: {', '.join(symbols)}\nDuraci√≥n: {duration}",
                parse_mode='HTML'
            )
            
        except Exception as e:
            error_msg = f"‚ùå Error en comando train: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /train: {e}")
    
    async def stop_training_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /stop_training - Detener entrenamiento"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'stop_training',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text("üõë Comando de detener entrenamiento enviado.")
            
        except Exception as e:
            error_msg = f"‚ùå Error en comando stop_training: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /stop_training: {e}")
    
    async def trade_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /trade - Iniciar trading"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Parsear argumentos del comando
            args = self._parse_command_args(context.args)
            mode = args.get('mode', 'paper')
            symbols = args.get('symbols', ['BTCUSDT', 'ETHUSDT'])
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'trade',
                'args': {'mode': mode, 'symbols': symbols},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(
                f"üíπ Comando de trading enviado:\nModo: {mode.upper()}\nS√≠mbolos: {', '.join(symbols)}",
                parse_mode='HTML'
            )
            
        except Exception as e:
            error_msg = f"‚ùå Error en comando trade: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /trade: {e}")
    
    async def stop_trading_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /stop_trading - Detener trading"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'stop_trading',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text("üõë Comando de detener trading enviado.")
            
        except Exception as e:
            error_msg = f"‚ùå Error en comando stop_trading: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /stop_trading: {e}")
    
    async def set_mode_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /set_mode - Cambiar modo"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Parsear argumentos del comando
            args = self._parse_command_args(context.args)
            mode = args.get('mode', 'paper')
            
            if mode not in ['paper', 'live']:
                await update.message.reply_text("‚ùå Modo inv√°lido. Usa 'paper' o 'live'.")
                return
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'set_mode',
                'args': {'mode': mode},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"‚öôÔ∏è Comando de cambiar modo enviado: {mode.upper()}")
            
        except Exception as e:
            error_msg = f"‚ùå Error en comando set_mode: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /set_mode: {e}")
    
    async def set_symbols_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /set_symbols - Cambiar s√≠mbolos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Parsear argumentos del comando
            args = self._parse_command_args(context.args)
            symbols = args.get('symbols', [])
            
            if not symbols:
                await update.message.reply_text("‚ùå No se proporcionaron s√≠mbolos.")
                return
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'set_symbols',
                'args': {'symbols': symbols},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"üìà Comando de cambiar s√≠mbolos enviado: {', '.join(symbols)}")
            
        except Exception as e:
            error_msg = f"‚ùå Error en comando set_symbols: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /set_symbols: {e}")
    
    async def shutdown_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /shutdown - Apagar sistema"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'shutdown',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text("üõë Comando de apagado enviado.")
            
        except Exception as e:
            error_msg = f"‚ùå Error en comando shutdown: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /shutdown: {e}")
    
    def _load_user_config(self) -> Dict[str, Any]:
        """Carga la configuraci√≥n del usuario desde user_settings.yaml"""
        try:
            # Usar la configuraci√≥n unificada
            return unified_config.user_settings
        except Exception as e:
            logger.error(f"‚ùå Error cargando configuraci√≥n de usuario: {e}")
            return {}
    
    def _parse_command_args(self, args: list) -> Dict[str, Any]:
        """Parsea argumentos de comando estilo argparse"""
        parsed_args = {}
        
        if not args:
            return parsed_args
        
        i = 0
        while i < len(args):
            arg = args[i]
            
            if arg.startswith('--'):
                # Argumento con valor
                key = arg[2:]  # Remover --
                if i + 1 < len(args) and not args[i + 1].startswith('-'):
                    value = args[i + 1]
                    # Convertir a lista si contiene comas
                    if ',' in value:
                        parsed_args[key] = [s.strip() for s in value.split(',')]
                    else:
                        parsed_args[key] = value
                    i += 2
                else:
                    # Argumento booleano
                    parsed_args[key] = True
                    i += 1
            else:
                # Argumento posicional
                if 'symbols' not in parsed_args:
                    parsed_args['symbols'] = [arg]
                else:
                    parsed_args['symbols'].append(arg)
                i += 1
        
        return parsed_args

    # Utilidades de formato seguro para Telegram HTML
    def _escape_html(self, text: str) -> str:
        try:
            return (
                text.replace('&', '&amp;')
                    .replace('<', '&lt;')
                    .replace('>', '&gt;')
            )
        except Exception:
            return text
    
    # ===== NUEVOS COMANDOS EXPANDIDOS =====
    
    # Comandos de Agentes y ML
    async def agents_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /agents - Estado de todos los agentes"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'agents_status',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text("ü§ñ Obteniendo estado de todos los agentes...")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo agentes: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /agents: {e}")
    
    async def agent_status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /agent_status - Estado de agente espec√≠fico"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbol = args.get('symbol', 'BTCUSDT')
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'agent_status',
                'args': {'symbol': symbol.upper()},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"ü§ñ Analizando agente para {symbol.upper()}...")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo estado del agente: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /agent_status: {e}")
    
    async def retrain_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /retrain - Reentrenar agente espec√≠fico"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbol = args.get('symbol', 'BTCUSDT')
            duration = args.get('duration', '4h')
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'retrain',
                'args': {'symbol': symbol.upper(), 'duration': duration},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"üéì Iniciando reentrenamiento de {symbol.upper()} por {duration}...")
            
        except Exception as e:
            error_msg = f"‚ùå Error en reentrenamiento: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /retrain: {e}")
    
    async def model_info_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /model_info - Informaci√≥n del modelo"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbol = args.get('symbol', 'BTCUSDT')
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'model_info',
                'args': {'symbol': symbol.upper()},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"üìä Obteniendo informaci√≥n del modelo para {symbol.upper()}...")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo informaci√≥n del modelo: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /model_info: {e}")
    
    async def training_status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /training_status - Estado del entrenamiento"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Llamar directamente al controlador
            await self.controller.handle_command('training_status', {}, str(update.message.chat_id))
            logger.info(f"‚úÖ Comando /training_status ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo estado de entrenamiento: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /training_status: {e}")
    
    async def train_hist_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /train_hist - Entrenamiento hist√≥rico con actualizaci√≥n en tiempo real por ciclos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Parsear argumentos del comando
            args = self._parse_command_args(context.args)
            cycle_size = args.get('cycle_size', 500)
            update_every = args.get('update_every', 25)
            
            # Obtener configuraci√≥n de s√≠mbolos y timeframes
            config = self._load_user_config()
            symbols = config.get("data_collection", {}).get("real_time", {}).get("symbols", [])
            timeframes = config.get("data_collection", {}).get("real_time", {}).get("timeframes", [])
            
            # Calcular total de ciclos (un ciclo por s√≠mbolo)
            total_cycles = len(symbols)
            
            # Enviar mensaje inicial
            initial_message = f"""üîß <b>Iniciando entrenamiento hist√≥rico</b>

üìä <b>Configuraci√≥n:</b>
‚Ä¢ S√≠mbolos: {', '.join(symbols[:5])}{'...' if len(symbols) > 5 else ''}
‚Ä¢ Timeframes: {', '.join(timeframes)}
‚Ä¢ Total ciclos: {total_cycles}
‚Ä¢ Ciclo: {cycle_size} barras
‚Ä¢ Actualizaci√≥n: cada {update_every} barras

‚è≥ <b>Estado:</b> Preparando pipeline de datos
üîÑ <b>Procesando:</b> Datos hist√≥ricos sincronizados
ü§ñ <b>Generando:</b> Modelos de IA por s√≠mbolo

Recibir√°s actualizaciones en tiempo real cada 10 segundos."""
            
            await update.message.reply_text(initial_message, parse_mode='HTML')
            
            # Procesar cada ciclo
            for cycle in range(total_cycles):
                current_symbol = symbols[cycle]
                
                # Enviar mensaje inicial para el ciclo
                cycle_message = await update.message.reply_text(
                    f"üîß <b>Iniciando entrenamiento hist√≥rico - Ciclo {cycle + 1}/{total_cycles}</b>\n\n"
                    f"‚Ä¢ S√≠mbolo actual: {current_symbol}\n"
                    f"‚Ä¢ Estado: Preparando pipeline\n"
                    f"‚Ä¢ Progreso: 0%\n"
                    f"‚Ä¢ S√≠mbolos procesados: Ninguno\n\n"
                    f"Este mensaje se actualizar√° cada 10 segundos.",
                    parse_mode='HTML'
                )
                
                message_id = cycle_message.message_id
                chat_id = update.message.chat_id
                
                # Ejecutar comando de terminal para el ciclo actual
                cmd = [
                    "python", "scripts/training/train_historical.py",
                    "--config", "config/user_settings.yaml",
                    "--cycle_size", str(cycle_size),
                    "--update_every", str(update_every),
                    "--symbol", current_symbol,
                    "--output-dir", "data/models"
                ]
                
                import subprocess
                import asyncio
                
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    encoding='utf-8',
                    errors='replace',
                    cwd=Path(__file__).parent.parent.parent
                )
                
                # Monitorear progreso del ciclo con actualizaciones en tiempo real
                progress = 0
                processed_symbols = []
                status = "Preparando pipeline"
                
                # Importar componentes para m√©tricas y auditor√≠a
                from control.metrics_sender import MetricsSender
                from control.security_guard import telegram_security
                
                # Inicializar MetricsSender si no existe
                if not hasattr(self, 'metrics_sender'):
                    self.metrics_sender = MetricsSender(self.telegram_bot, self.telegram_bot.get_config()['telegram'])
                
                while process.poll() is None:
                    # Simular progreso (en producci√≥n, usar m√©tricas reales)
                    progress = min(progress + 10, 100)
                    
                    if progress % 30 == 0 and current_symbol not in processed_symbols:
                        processed_symbols.append(current_symbol)
                        status = "Entrenando modelos"
                    elif progress >= 80:
                        status = "Validando modelos"
                    elif progress >= 50:
                        status = "Optimizando par√°metros"
                    elif progress >= 20:
                        status = "Procesando datos"
                    
                    # Obtener m√©tricas usando MetricsSender
                    metrics = await self.metrics_sender.get_training_metrics(
                        cycle=cycle,
                        symbol=current_symbol,
                        total_cycles=total_cycles
                    )
                    metrics['progress'] = progress
                    metrics['status'] = status
                    metrics['symbols_processed'] = processed_symbols
                    
                    # Actualizar mensaje usando MetricsSender
                    success = await self.metrics_sender.send_training_progress_update(
                        chat_id=chat_id,
                        message_id=message_id,
                        metrics=metrics
                    )
                    
                    # Auditor√≠a de actualizaci√≥n
                    telegram_security.audit_training_update(
                        cycle=cycle + 1,
                        symbol=current_symbol,
                        progress=progress,
                        chat_id=str(chat_id)
                    )
                    
                    if success:
                        logger.info(f"‚úÖ Actualizaci√≥n ciclo {cycle + 1}: {progress}% - {status}")
                    else:
                        logger.warning(f"‚ö†Ô∏è Error actualizando mensaje ciclo {cycle + 1}")
                    
                    await asyncio.sleep(10)  # Actualizar cada 10 segundos
                
                # Verificar resultado del ciclo
                stdout, stderr = process.communicate()
                
                if process.returncode == 0:
                    # Mensaje final del ciclo
                    final_message = (
                        f"‚úÖ <b>Entrenamiento hist√≥rico completado - Ciclo {cycle + 1}/{total_cycles}</b>\n\n"
                        f"‚Ä¢ S√≠mbolo: {current_symbol}\n"
                        f"‚Ä¢ Estado: Completado\n"
                        f"‚Ä¢ Progreso: 100%\n"
                        f"‚Ä¢ Modelos guardados en: data/models/{current_symbol}/\n"
                        f"‚Ä¢ Resumen: reports/train_hist_summary_cycle_{cycle + 1}.json"
                    )
                    
                    try:
                        await context.bot.edit_message_text(
                            chat_id=chat_id,
                            message_id=message_id,
                            text=final_message,
                            parse_mode='HTML'
                        )
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Error actualizando mensaje final ciclo {cycle + 1}: {e}")
                    
                    # Auditor√≠a de ciclo completado exitosamente
                    telegram_security.audit_training_cycle(
                        cycle=cycle + 1,
                        symbol=current_symbol,
                        status="completed",
                        chat_id=str(chat_id),
                        success=True
                    )
                    
                    logger.info(f"‚úÖ Ciclo {cycle + 1} completado para {current_symbol}")
                    
                else:
                    # Mensaje de error del ciclo
                    error_message = (
                        f"‚ùå <b>Error en entrenamiento hist√≥rico - Ciclo {cycle + 1}/{total_cycles}</b>\n\n"
                        f"‚Ä¢ S√≠mbolo: {current_symbol}\n"
                        f"‚Ä¢ Estado: Error\n"
                        f"‚Ä¢ Error: {stderr.decode() if stderr else 'Error desconocido'}"
                    )
                    
                    try:
                        await context.bot.edit_message_text(
                            chat_id=chat_id,
                            message_id=message_id,
                            text=error_message,
                            parse_mode='HTML'
                        )
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Error actualizando mensaje de error ciclo {cycle + 1}: {e}")
                    
                    # Auditor√≠a de ciclo con error
                    telegram_security.audit_training_cycle(
                        cycle=cycle + 1,
                        symbol=current_symbol,
                        status="error",
                        chat_id=str(chat_id),
                        success=False
                    )
                    
                    logger.error(f"‚ùå Error en ciclo {cycle + 1} para {current_symbol}: {stderr.decode() if stderr else 'Error desconocido'}")
                    break  # Detener si hay error
                
                # Notificar inicio del pr√≥ximo ciclo o fin del entrenamiento
                if cycle + 1 < total_cycles:
                    await update.message.reply_text(
                        f"‚è≠Ô∏è <b>Preparando ciclo {cycle + 2}/{total_cycles}</b>\n\n"
                        f"‚Ä¢ Siguiente s√≠mbolo: {symbols[cycle + 1]}\n"
                        f"‚Ä¢ Estado: Iniciando en 5 segundos...",
                        parse_mode='HTML'
                    )
                    await asyncio.sleep(5)  # Pausa entre ciclos
                else:
                    # Mensaje final del entrenamiento completo
                    await update.message.reply_text(
                        f"üéâ <b>Entrenamiento hist√≥rico finalizado</b>\n\n"
                        f"‚Ä¢ Todos los ciclos completados: {total_cycles}\n"
                        f"‚Ä¢ S√≠mbolos procesados: {', '.join(symbols)}\n"
                        f"‚Ä¢ Modelos guardados en: data/models/\n"
                        f"‚Ä¢ Resumen completo: reports/train_hist_summary.json\n"
                        f"‚Ä¢ Tiempo total: ~{total_cycles * 2} minutos\n\n"
                        f"‚úÖ Estado: Entrenamiento exitoso",
                        parse_mode='HTML'
                    )
            
            logger.info(f"‚úÖ Comando /train_hist completado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error iniciando entrenamiento hist√≥rico: {str(e)}"
            await update.message.reply_text(error_msg, parse_mode='HTML')
            logger.error(f"‚ùå Error en /train_hist: {e}")
    
    async def train_live_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /train_live - Entrenamiento en vivo"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Parsear argumentos del comando
            args = self._parse_command_args(context.args)
            cycle_minutes = args.get('cycle_minutes', 30)
            update_every = args.get('update_every', 5)
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Llamar directamente al controlador
            await self.controller.handle_command('train_live', {
                'cycle_minutes': cycle_minutes,
                'update_every': update_every
            }, str(update.message.chat_id))
            
            logger.info(f"‚úÖ Comando /train_live ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error iniciando entrenamiento en vivo: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /train_live: {e}")
    
    # Comandos de Datos y An√°lisis
    async def download_data_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /download_data - An√°lisis y descarga completa de datos hist√≥ricos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Mensaje inicial
            await update.message.reply_text(
                "üîÑ <b>Iniciando an√°lisis y descarga de datos hist√≥ricos</b>\n\n"
                "üìä <b>Proceso:</b>\n"
                "1Ô∏è‚É£ Analizando historial existente\n"
                "2Ô∏è‚É£ Identificando datos faltantes\n"
                "3Ô∏è‚É£ Descargando datos desde 1 a√±o hasta ahora\n"
                "4Ô∏è‚É£ Alineando temporalmente\n"
                "5Ô∏è‚É£ Guardando en base de datos\n\n"
                "‚è≥ Esto puede tomar varios minutos...",
                parse_mode='HTML'
            )
            
            # Importar m√≥dulos necesarios
            from config.config_loader import ConfigLoader
            from core.data.database import db_manager
            from core.data.collector import BitgetDataCollector, download_extensive_historical_data
            from core.data.temporal_alignment import TemporalAlignment
            from datetime import datetime, timezone, timedelta
            from pathlib import Path
            import asyncio
            
            # Cargar configuraci√≥n
            config_loader = ConfigLoader("config/user_settings.yaml")
            config = config_loader.load_config()
            real_time_config = config.get("data_collection", {}).get("real_time", {})
            symbols = real_time_config.get("symbols", [])
            timeframes = real_time_config.get("timeframes", ["1m", "5m", "15m", "1h", "4h", "1d"])
            
            if not symbols:
                await update.message.reply_text("‚ùå No hay s√≠mbolos configurados en user_settings.yaml")
                return
            
            # Inicializar componentes
            collector = BitgetDataCollector()
            aligner = TemporalAlignment()
            now = datetime.now(timezone.utc)
            one_year_ago = now - timedelta(days=365)
            
            # An√°lisis inicial
            await update.message.reply_text("üìä <b>Paso 1/5:</b> Analizando historial existente...", parse_mode='HTML')
            
            analysis_results = {}
            missing_data = {}
            
            for symbol in symbols:
                symbol_analysis = {
                    'symbol': symbol,
                    'timeframes': {},
                    'needs_download': False,
                    'needs_alignment': False
                }
                
                for timeframe in timeframes:
                    # Verificar √∫ltimo timestamp
                    last_timestamp = db_manager.get_last_timestamp(symbol, timeframe)
                    
                    if last_timestamp:
                        last_dt = datetime.fromtimestamp(last_timestamp, tz=timezone.utc)
                        time_diff = now - last_dt
                        
                        if time_diff.total_seconds() > 3600:  # M√°s de 1 hora
                            symbol_analysis['timeframes'][timeframe] = {
                                'last_data': last_dt,
                                'missing_hours': time_diff.total_seconds() / 3600,
                                'needs_download': True
                            }
                            symbol_analysis['needs_download'] = True
                        else:
                            symbol_analysis['timeframes'][timeframe] = {
                                'last_data': last_dt,
                                'missing_hours': 0,
                                'needs_download': False
                            }
                    else:
                        symbol_analysis['timeframes'][timeframe] = {
                            'last_data': None,
                            'missing_hours': 'N/A',
                            'needs_download': True
                        }
                        symbol_analysis['needs_download'] = True
                
                analysis_results[symbol] = symbol_analysis
            
            # Enviar resumen del an√°lisis
            analysis_msg = "üìä <b>An√°lisis completado:</b>\n\n"
            for symbol, analysis in analysis_results.items():
                if analysis['needs_download']:
                    analysis_msg += f"üî¥ <b>{symbol}</b>: Necesita descarga\n"
                    for tf, info in analysis['timeframes'].items():
                        if info['needs_download']:
                            if info['last_data']:
                                analysis_msg += f"   ‚Ä¢ {tf}: √öltimo dato {info['last_data'].strftime('%Y-%m-%d %H:%M')}\n"
                            else:
                                analysis_msg += f"   ‚Ä¢ {tf}: Sin datos\n"
                else:
                    analysis_msg += f"üü¢ <b>{symbol}</b>: Datos actualizados\n"
            
            await update.message.reply_text(analysis_msg, parse_mode='HTML')
            
            # Descargar datos faltantes
            if any(analysis['needs_download'] for analysis in analysis_results.values()):
                await update.message.reply_text("üì• <b>Paso 2/5:</b> Descargando datos faltantes...", parse_mode='HTML')
                
                download_results = {}
                for symbol, analysis in analysis_results.items():
                    if not analysis['needs_download']:
                        continue
                    
                    symbol_msg = f"üì• Descargando <b>{symbol}</b>...\n"
                    await update.message.reply_text(symbol_msg, parse_mode='HTML')
                    
                    try:
                        # Descargar datos desde 1 a√±o atr√°s hasta ahora
                        download_result = await download_extensive_historical_data(
                            symbols=[symbol],
                            timeframes=timeframes,
                            start_date=one_year_ago,
                            end_date=now
                        )
                        
                        if download_result and download_result.get('data'):
                            # Guardar datos por timeframe
                            for timeframe in timeframes:
                                if timeframe in download_result['data']:
                                    db_path = f"data/{symbol}/{symbol}_{timeframe}.db"
                                    Path(f"data/{symbol}").mkdir(parents=True, exist_ok=True)
                                    
                                    success = db_manager.store_historical_data(
                                        download_result['data'][timeframe], 
                                        symbol, 
                                        timeframe, 
                                        db_path
                                    )
                                    
                                    if success:
                                        download_results[f"{symbol}_{timeframe}"] = len(download_result['data'][timeframe])
                                    else:
                                        await update.message.reply_text(f"‚ùå Error guardando {symbol} {timeframe}")
                        
                        await update.message.reply_text(f"‚úÖ <b>{symbol}</b> descargado correctamente", parse_mode='HTML')
                        
                    except Exception as e:
                        await update.message.reply_text(f"‚ùå Error descargando {symbol}: {str(e)}")
                        logger.error(f"Error descargando {symbol}: {e}")
                        continue
                
                # Resumen de descarga
                if download_results:
                    total_records = sum(download_results.values())
                    summary_msg = f"üìä <b>Descarga completada:</b>\n\n"
                    summary_msg += f"üìà Total de registros: {total_records:,}\n"
                    summary_msg += f"üìÅ Archivos creados: {len(download_results)}\n\n"
                    
                    for key, count in list(download_results.items())[:5]:  # Mostrar solo los primeros 5
                        summary_msg += f"‚Ä¢ {key}: {count:,} registros\n"
                    
                    if len(download_results) > 5:
                        summary_msg += f"‚Ä¢ ... y {len(download_results) - 5} m√°s\n"
                    
                    await update.message.reply_text(summary_msg, parse_mode='HTML')
            else:
                await update.message.reply_text("‚úÖ Todos los datos est√°n actualizados, no se necesita descarga", parse_mode='HTML')
            
            # Alineaci√≥n temporal
            await update.message.reply_text("üîÑ <b>Paso 3/5:</b> Alineando datos temporalmente...", parse_mode='HTML')
            
            try:
                # Crear alineador temporal
                aligner = TemporalAlignment()
                
                # Alinear datos para cada timeframe
                alignment_results = {}
                for timeframe in timeframes:
                    try:
                        # Obtener datos de todos los s√≠mbolos para este timeframe
                        symbol_data = {}
                        for symbol in symbols:
                            db_path = f"data/{symbol}/{symbol}_{timeframe}.db"
                            if Path(db_path).exists():
                                # Leer datos de la base de datos
                                import sqlite3
                                with sqlite3.connect(db_path) as conn:
                                    df = pd.read_sql_query(
                                        "SELECT * FROM market_data ORDER BY timestamp", 
                                        conn, 
                                        index_col='timestamp',
                                        parse_dates=['timestamp']
                                    )
                                    if not df.empty:
                                        symbol_data[symbol] = df
                        
                        if symbol_data:
                            # Alinear datos
                            aligned_data = aligner.align_symbol_data(symbol_data, None, timeframe)
                            
                            if aligned_data:
                                # Guardar datos alineados
                                session_id = f"download_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                                success = db_manager.store_aligned_data(aligned_data, timeframe, session_id)
                                
                                if success:
                                    alignment_results[timeframe] = len(aligned_data)
                                    await update.message.reply_text(f"‚úÖ Alineaci√≥n {timeframe} completada")
                                else:
                                    await update.message.reply_text(f"‚ùå Error guardando alineaci√≥n {timeframe}")
                            
                    except Exception as e:
                        await update.message.reply_text(f"‚ùå Error alineando {timeframe}: {str(e)}")
                        logger.error(f"Error alineando {timeframe}: {e}")
                        continue
                
                # Resumen de alineaci√≥n
                if alignment_results:
                    total_aligned = sum(alignment_results.values())
                    align_msg = f"üîÑ <b>Alineaci√≥n completada:</b>\n\n"
                    align_msg += f"üìä Total de per√≠odos alineados: {total_aligned:,}\n"
                    align_msg += f"‚è∞ Timeframes procesados: {len(alignment_results)}\n"
                    
                    await update.message.reply_text(align_msg, parse_mode='HTML')
                else:
                    await update.message.reply_text("‚ö†Ô∏è No se pudo completar la alineaci√≥n temporal")
                    
            except Exception as e:
                await update.message.reply_text(f"‚ùå Error en alineaci√≥n temporal: {str(e)}")
                logger.error(f"Error en alineaci√≥n temporal: {e}")
            
            # Verificaci√≥n final
            await update.message.reply_text("üîç <b>Paso 4/5:</b> Verificando integridad de datos...", parse_mode='HTML')
            
            # Obtener resumen final de la base de datos
            final_summary = db_manager.get_data_summary_optimized()
            
            if final_summary and 'symbols' in final_summary:
                final_msg = "üìä <b>Verificaci√≥n final completada:</b>\n\n"
                final_msg += f"üìà Total de s√≠mbolos: {final_summary['total_symbols']}\n"
                final_msg += f"üìä Total de registros: {final_summary['total_records']:,}\n"
                final_msg += f"üíæ Tama√±o de BD: {final_summary['database_size_mb']:.1f} MB\n\n"
                
                # Mostrar estado de cada s√≠mbolo
                for symbol_info in final_summary['symbols'][:5]:  # Solo los primeros 5
                    status_emoji = "üü¢" if symbol_info['status'] == 'OK' else "üî¥"
                    final_msg += f"{status_emoji} <b>{symbol_info['symbol']}</b>: {symbol_info['record_count']:,} registros\n"
                
                if len(final_summary['symbols']) > 5:
                    final_msg += f"... y {len(final_summary['symbols']) - 5} s√≠mbolos m√°s\n"
                
                await update.message.reply_text(final_msg, parse_mode='HTML')
            
            # Mensaje final
            await update.message.reply_text(
                "üéâ <b>Proceso completado exitosamente!</b>\n\n"
                "‚úÖ Datos hist√≥ricos analizados\n"
                "‚úÖ Datos faltantes descargados\n"
                "‚úÖ Alineaci√≥n temporal realizada\n"
                "‚úÖ Datos guardados en base de datos\n\n"
                "üöÄ El sistema est√° listo para trading",
                parse_mode='HTML'
            )
            
            # Enviar listado de comandos despu√©s de 10 segundos
            import asyncio
            asyncio.create_task(self._send_commands_after_delay(update, 10))
            
        except Exception as e:
            error_msg = f"‚ùå Error en descarga de datos: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /download_data: {e}")
            import traceback
            traceback.print_exc()
    
    async def analyze_data_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /analyze_data - Analizar datos hist√≥ricos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbols = args.get('symbols') or ([args.get('symbol')] if args.get('symbol') else None)
            no_repair = args.get('no-repair', False) or args.get('norepair', False)
            
            # Construir comando
            cmd = ["python", "scripts/data/analyze_data.py"]
            if symbols:
                cmd += ["--symbols", ",".join([s.upper() for s in symbols])]
            if no_repair:
                cmd += ["--no-repair"]
            
            await update.message.reply_text("üìä Iniciando an√°lisis de datos hist√≥ricos‚Ä¶")
            
            import subprocess
            from pathlib import Path
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='replace',
                cwd=Path(__file__).parent.parent
            )
            stdout, stderr = process.communicate()

            if stdout:
                # Intentar segmentar por s√≠mbolo
                lines = stdout.strip().splitlines()
                symbol_chunks = []
                current_symbol = None
                current_lines = []
                preamble_lines = []
                for line in lines:
                    if line.startswith("üéØ S√≠mbolo:"):
                        if current_symbol is None and current_lines:
                            preamble_lines = current_lines
                            current_lines = []
                        if current_symbol is not None:
                            symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))
                            current_lines = []
                        current_symbol = line.replace("üéØ S√≠mbolo:", "").strip()
                        current_lines.append(line)
                    else:
                        current_lines.append(line)
                if current_symbol is not None and current_lines:
                    symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))

                import asyncio as _asyncio
                if preamble_lines:
                    preamble = "\n".join(preamble_lines)
                    preamble = preamble[-3500:]
                    preamble = self._escape_html(preamble)
                    await update.message.reply_text(f"<b>üìä An√°lisis de datos</b>\n\n<code>{preamble}</code>", parse_mode='HTML')

                if symbol_chunks:
                    total = len(symbol_chunks)
                    for idx, (sym, chunk_text) in enumerate(symbol_chunks, 1):
                        text = chunk_text[-3500:] if len(chunk_text) > 3500 else chunk_text
                        sym_safe = self._escape_html(sym)
                        text = self._escape_html(text)
                        header = f"<b>üìä {sym_safe} ({idx}/{total})</b>\n\n"
                        text = self._escape_html(text)
                        await update.message.reply_text(header + f"<code>{text}</code>", parse_mode='HTML')
                        if idx < total:
                            await _asyncio.sleep(5)
                else:
                    tail = "\n".join(lines[-25:])
                    tail = self._escape_html(tail)
                    await update.message.reply_text(f"<b>Resultado</b>\n\n<code>{tail}</code>", parse_mode='HTML')
            if process.returncode != 0:
                error_text = stderr[-1500:] if stderr else 'Error desconocido'
                error_text = self._escape_html(error_text)
                await update.message.reply_text(f"‚ùå Error:\n\n<code>{error_text}</code>", parse_mode='HTML')
            else:
                await update.message.reply_text("‚úÖ An√°lisis completado")
                # Enviar listado de comandos despu√©s de 10 segundos
                import asyncio
                asyncio.create_task(self._send_commands_after_delay(update, 10))
            
        except Exception as e:
            error_msg = f"‚ùå Error analizando datos: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /analyze_data: {e}")
    
    async def align_data_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /align_data - Alinear datos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbols = args.get('symbols')
            timeframes = args.get('timeframes')
            
            cmd = ["python", "-u", "scripts/data/verify_align.py"]
            if symbols:
                cmd += ["--symbols", ",".join([s.upper() for s in symbols])]
            if timeframes:
                cmd += ["--timeframes", ",".join(timeframes)]
            
            await update.message.reply_text("üîÑ Iniciando verificaci√≥n/alineaci√≥n‚Ä¶")
            
            import subprocess
            from pathlib import Path
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='replace',
                cwd=Path(__file__).parent.parent,
                bufsize=1
            )

            # Lectura en tiempo real para progreso
            import asyncio as _asyncio
            lines_collected = []
            total_symbols = None
            last_progress_sent = -1
            async def _send_progress(current:int, total:int):
                nonlocal last_progress_sent
                if total <= 0 or current == last_progress_sent:
                    return
                last_progress_sent = current
                width = 20
                filled = int(width * current / max(total, 1))
                bar = '‚ñà' * filled + '‚ñë' * (width - filled)
                await update.message.reply_text(f"<b>Progreso</b> {current}/{total} {bar}", parse_mode='HTML')

            # Enviar pre√°mbulo si detectamos cabecera con totales
            while True:
                line = process.stdout.readline()
                if not line:
                    if process.poll() is not None:
                        break
                    await _asyncio.sleep(0.1)
                    continue
                lines_collected.append(line.rstrip('\n'))
                # Detectar totales: "üîÑ Verificando alineaci√≥n | S√≠mbolos: X | TFs: ..."
                if total_symbols is None and "S√≠mbolos:" in line:
                    try:
                        # extraer el n√∫mero despu√©s de 'S√≠mbolos:'
                        part = line.split("S√≠mbolos:")[-1].strip()
                        total_symbols = int(part.split('|')[0].strip())
                    except Exception:
                        total_symbols = None
                # Detectar avance por s√≠mbolo: "üîÑ Procesando s√≠mbolo i/N: ..."
                if "Procesando s√≠mbolo" in line and "/" in line:
                    try:
                        frag = line.split(":")[0]
                        nums = frag.split()[-1]  # i/N
                        cur, tot = nums.split('/')
                        cur_i = int(cur)
                        tot_i = int(tot)
                        await _send_progress(cur_i, tot_i)
                    except Exception:
                        pass

            # Obtener stdout/stderr completos para formateo final
            stdout = "\n".join(lines_collected)
            stderr = process.stderr.read()

            if stdout:
                lines = stdout.strip().splitlines()
                symbol_chunks = []
                current_symbol = None
                current_lines = []
                preamble_lines = []
                for line in lines:
                    if line.startswith("üéØ S√≠mbolo:"):
                        if current_symbol is None and current_lines:
                            preamble_lines = current_lines
                            current_lines = []
                        if current_symbol is not None:
                            symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))
                            current_lines = []
                        current_symbol = line.replace("üéØ S√≠mbolo:", "").strip()
                        current_lines.append(line)
                    else:
                        current_lines.append(line)
                if current_symbol is not None and current_lines:
                    symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))

                import asyncio as _asyncio
                if preamble_lines:
                    preamble = "\n".join(preamble_lines)
                    preamble = preamble[-3500:]
                    preamble = self._escape_html(preamble)
                    await update.message.reply_text(f"<b>üîÑ Verificar/Alinear</b>\n\n<code>{preamble}</code>", parse_mode='HTML')

                if symbol_chunks:
                    total = len(symbol_chunks)
                    for idx, (sym, chunk_text) in enumerate(symbol_chunks, 1):
                        text = chunk_text[-3500:] if len(chunk_text) > 3500 else chunk_text
                        sym_safe = self._escape_html(sym)
                        text = self._escape_html(text)
                        header = f"<b>üîÑ {sym_safe} ({idx}/{total})</b>\n\n"
                        text = self._escape_html(text)
                        await update.message.reply_text(header + f"<code>{text}</code>", parse_mode='HTML')
                        if idx < total:
                            await _asyncio.sleep(5)
                else:
                    tail = "\n".join(lines[-25:])
                    tail = self._escape_html(tail)
                    await update.message.reply_text(f"<b>Resultado</b>\n\n<code>{tail}</code>", parse_mode='HTML')
            if process.returncode != 0:
                error_text = stderr[-1500:] if stderr else 'Error desconocido'
                error_text = self._escape_html(error_text)
                await update.message.reply_text(f"‚ùå Error:\n\n<code>{error_text}</code>", parse_mode='HTML')
            else:
                await update.message.reply_text("‚úÖ Alineaci√≥n verificada/actualizada")
            
        except Exception as e:
            error_msg = f"‚ùå Error alineando datos: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /align_data: {e}")
    
    async def data_status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /data_status - Estado de los datos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Ejecutar script de estado de datos directamente
            args = self._parse_command_args(context.args)
            symbols = args.get('symbols')
            timeframes = args.get('timeframes')

            cmd = ["python", "-u", "scripts/data/data_status.py"]
            if symbols:
                cmd += ["--symbols", ",".join([s.upper() for s in symbols])]
            if timeframes:
                cmd += ["--timeframes", ",".join(timeframes)]

            await update.message.reply_text("üìä Obteniendo estado de los datos‚Ä¶")

            import subprocess
            from pathlib import Path
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='replace',
                cwd=Path(__file__).parent.parent,
                bufsize=1
            )

            # Lectura en tiempo real para progreso
            import asyncio as _asyncio
            lines_collected = []
            total_symbols = None
            last_progress_sent = -1
            symbols_seen = 0
            async def _send_progress(current:int, total:int|None):
                nonlocal last_progress_sent
                if current == last_progress_sent:
                    return
                last_progress_sent = current
                width = 20
                denom = total if (isinstance(total, int) and total > 0) else max(current, 1)
                filled = int(width * current / denom)
                bar = '‚ñà' * filled + '‚ñë' * (width - filled)
                suffix = f"{current}/{total}" if isinstance(total, int) and total > 0 else f"{current}"
                await update.message.reply_text(f"<b>Progreso</b> {suffix} {bar}", parse_mode='HTML')

            while True:
                line = process.stdout.readline()
                if not line:
                    if process.poll() is not None:
                        break
                    await _asyncio.sleep(0.1)
                    continue
                line = line.rstrip('\n')
                lines_collected.append(line)
                # Detectar totales en pre√°mbulo: "S√≠mbolos: X"
                if total_symbols is None and "S√≠mbolos:" in line:
                    try:
                        part = line.split("S√≠mbolos:")[-1].strip()
                        total_symbols = int(part.split('|')[0].strip())
                    except Exception:
                        total_symbols = None
                # Detectar avance expl√≠cito: "Procesando s√≠mbolo i/N"
                if "Procesando s√≠mbolo" in line and "/" in line:
                    try:
                        frag = line.split(":")[0]
                        nums = frag.split()[-1]  # i/N
                        cur, tot = nums.split('/')
                        cur_i = int(cur)
                        tot_i = int(tot)
                        await _send_progress(cur_i, tot_i)
                        continue
                    except Exception:
                        pass
                # Si no hay l√≠nea de progreso, contar s√≠mbolos ya emitidos
                if line.startswith("üéØ S√≠mbolo:"):
                    symbols_seen += 1
                    await _send_progress(symbols_seen, total_symbols)

            stdout = "\n".join(lines_collected)
            stderr = process.stderr.read()

            if stdout:
                # Separar por s√≠mbolo si el script imprime cabeceras "üéØ S√≠mbolo:"
                lines = stdout.strip().splitlines()
                symbol_chunks = []
                current_symbol = None
                current_lines = []
                preamble_lines = []
                for line in lines:
                    if line.startswith("üéØ S√≠mbolo:"):
                        if current_symbol is None and current_lines:
                            preamble_lines = current_lines
                            current_lines = []
                        if current_symbol is not None:
                            symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))
                            current_lines = []
                        current_symbol = line.replace("üéØ S√≠mbolo:", "").strip()
                        current_lines.append(line)
                    else:
                        current_lines.append(line)
                if current_symbol is not None and current_lines:
                    symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))

                # Enviar pre√°mbulo si existe
                if preamble_lines:
                    preamble = "\n".join(preamble_lines)
                    preamble = preamble[-3500:]
                    # escapar
                    try:
                        preamble = preamble.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                    except Exception:
                        pass
                    await update.message.reply_text(f"<b>üìä Estado de datos</b>\n\n<code>{preamble}</code>", parse_mode='HTML')

                # Enviar por s√≠mbolo con delay de 5s
                import asyncio as _asyncio
                if symbol_chunks:
                    total = len(symbol_chunks)
                    for idx, (sym, chunk_text) in enumerate(symbol_chunks, 1):
                        # Limitar tama√±o por mensaje
                        text = chunk_text
                        if len(text) > 3500:
                            text = text[-3500:]
                        # escapar
                        try:
                            sym_safe = sym.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                            text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                        except Exception:
                            sym_safe = sym
                        header = f"<b>üìä {sym_safe} ({idx}/{total})</b>\n\n"
                        text = self._escape_html(text)
                        await update.message.reply_text(header + f"<code>{text}</code>", parse_mode='HTML')
                        if idx < total:
                            await _asyncio.sleep(5)
                else:
                    # Fallback a paginado por longitud si no hay cabeceras por s√≠mbolo
                    text = stdout.strip()
                    if len(text) > 60000:
                        text = text[-60000:]
                    chunk_size = 3500
                    chunks = [text[i:i+chunk_size] for i in range(0, len(text), chunk_size)] or [text]
                    total = len(chunks)
                    for idx, chunk in enumerate(chunks, 1):
                        header = f"<b>üìä Estado de datos ({idx}/{total})</b>\n\n"
                        chunk = self._escape_html(chunk)
                        await update.message.reply_text(header + f"<code>{chunk}</code>", parse_mode='HTML')
            if process.returncode != 0:
                error_text = stderr[-1500:] if stderr else 'Error desconocido'
                error_text = self._escape_html(error_text)
                await update.message.reply_text(f"‚ùå Error:\n\n<code>{error_text}</code>", parse_mode='HTML')
            else:
                # Enviar listado de comandos despu√©s de 10 segundos si fue exitoso
                import asyncio
                asyncio.create_task(self._send_commands_after_delay(update, 10))

        except Exception as e:
            error_msg = f"‚ùå Error obteniendo estado de datos: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /data_status: {e}")
    
    async def backtest_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /backtest - Backtest de estrategia"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbol = args.get('symbol', 'BTCUSDT')
            days = args.get('days', 7)
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'backtest',
                'args': {'symbol': symbol.upper(), 'days': days},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"üß™ Ejecutando backtest de {symbol.upper()} ({days} d√≠as)...")
            
        except Exception as e:
            error_msg = f"‚ùå Error ejecutando backtest: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /backtest: {e}")
    
    # Comandos de Trading Avanzado
    async def close_position_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /close_position - Cerrar posici√≥n espec√≠fica"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbol = args.get('symbol', 'BTCUSDT')
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'close_position',
                'args': {'symbol': symbol.upper()},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"üîÑ Cerrando posici√≥n de {symbol.upper()}...")
            
        except Exception as e:
            error_msg = f"‚ùå Error cerrando posici√≥n: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /close_position: {e}")
    
    # Comandos de Reportes
    async def performance_report_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /performance_report - Reporte de rendimiento"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'performance_report',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text("üìä Generando reporte de rendimiento...")
            
        except Exception as e:
            error_msg = f"‚ùå Error generando reporte: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /performance_report: {e}")
    
    async def agent_analysis_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /agent_analysis - An√°lisis detallado de agente"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbol = args.get('symbol', 'BTCUSDT')
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'agent_analysis',
                'args': {'symbol': symbol.upper()},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"üîç Analizando agente de {symbol.upper()}...")
            
        except Exception as e:
            error_msg = f"‚ùå Error analizando agente: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /agent_analysis: {e}")
    
    async def risk_report_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /risk_report - Reporte de riesgo"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'risk_report',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text("‚ö†Ô∏è Generando reporte de riesgo...")
            
        except Exception as e:
            error_msg = f"‚ùå Error generando reporte de riesgo: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /risk_report: {e}")
    
    async def trades_history_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /trades_history - Historial de trades"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            days = args.get('days', 7)
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'trades_history',
                'args': {'days': days},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"üìà Obteniendo historial de trades ({days} d√≠as)...")
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo historial: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /trades_history: {e}")
    
    # Comandos de Mantenimiento
    async def restart_system_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /restart_system - Reiniciar sistema"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Confirmar reinicio
            confirmation_msg = """
üîÑ <b>CONFIRMAR REINICIO DEL SISTEMA</b>

‚ö†Ô∏è <b>ADVERTENCIA:</b> Esto reiniciar√° todo el sistema.

¬øContinuar? Responde <b>YES</b> para confirmar.
            """
            
            await update.message.reply_text(confirmation_msg, parse_mode='HTML')
            
            # Enviar comando de confirmaci√≥n a la cola
            await self.controller.command_queue.put({
                'type': 'confirm_restart',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
        except Exception as e:
            error_msg = f"‚ùå Error en reinicio: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /restart_system: {e}")
    
    async def clear_cache_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /clear_cache - Limpiar cache"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'clear_cache',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text("üßπ Limpiando cache del sistema...")
            
        except Exception as e:
            error_msg = f"‚ùå Error limpiando cache: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /clear_cache: {e}")
    
    async def update_models_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /update_models - Actualizar modelos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'update_models',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text("üîÑ Actualizando modelos...")
            
        except Exception as e:
            error_msg = f"‚ùå Error actualizando modelos: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /update_models: {e}")
    
    # Comando de configuraci√≥n adicional
    async def set_leverage_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /set_leverage - Cambiar leverage"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbol = args.get('symbol', 'BTCUSDT')
            leverage = args.get('leverage', 10)
            
            if not (1 <= leverage <= 30):
                await update.message.reply_text("‚ùå Leverage debe estar entre 1 y 30.")
                return
            
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando al controlador
            await self.controller.command_queue.put({
                'type': 'set_leverage',
                'args': {'symbol': symbol.upper(), 'leverage': leverage},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(f"‚öôÔ∏è Cambiando leverage de {symbol.upper()} a {leverage}x...")
            
        except Exception as e:
            error_msg = f"‚ùå Error cambiando leverage: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /set_leverage: {e}")
    
    async def download_history_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /download_history - Descargar datos hist√≥ricos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Obtener configuraci√≥n de s√≠mbolos y timeframes
            config = self._load_user_config()
            symbols = config.get("data_collection", {}).get("real_time", {}).get("symbols", [])
            timeframes = config.get("data_collection", {}).get("real_time", {}).get("timeframes", [])
            
            # Enviar mensaje inicial
            initial_message = f"""üì• <b>Iniciando descarga de datos hist√≥ricos...</b>

üìä <b>Configuraci√≥n:</b>
‚Ä¢ S√≠mbolos: {', '.join(symbols[:5])}{'...' if len(symbols) > 5 else ''}
‚Ä¢ Timeframes: {', '.join(timeframes)}
‚Ä¢ A√±os: 1 a√±o de datos hist√≥ricos

‚è≥ <b>Estado:</b> Verificando datos existentes
üîÑ <b>Procesando:</b> Descargando datos faltantes
üîç <b>Auditando:</b> Duplicados y gaps
üîß <b>Reparando:</b> Inconsistencias

Recibir√°s actualizaciones en tiempo real."""
            
            await update.message.reply_text(initial_message, parse_mode='HTML')
            
            # Importar y usar el m√≥dulo de descarga de core/
            from core.data.history_downloader import history_downloader
            
            # Funci√≥n callback para progreso en tiempo real
            async def progress_callback(progress):
                progress_msg = f"""üìä <b>Progreso descarga</b>

‚Ä¢ S√≠mbolo: {progress.symbol}
‚Ä¢ Timeframe: {progress.timeframe}
‚Ä¢ Progreso: {progress.progress_percentage:.1f}%
‚Ä¢ Registros: {progress.records_downloaded:,}
‚Ä¢ Tiempo: {progress.elapsed_time}"""
                
                await update.message.reply_text(progress_msg, parse_mode='HTML')
            
            # Ejecutar descarga usando el m√≥dulo de core/
            download_results = await history_downloader.download_historical_data(
                symbols=symbols,
                timeframes=timeframes,
                days_back=365,
                progress_callback=progress_callback
            )
            
            # Generar mensaje de √©xito
            success_message = f"""‚úÖ <b>Descarga de datos hist√≥ricos completada</b>

üìÅ <b>Resultados:</b>
‚Ä¢ Datos guardados en: data/historical/
‚Ä¢ S√≠mbolos procesados: {download_results['symbols_requested']}
‚Ä¢ Timeframes: {', '.join(timeframes)}
‚Ä¢ Combinaciones exitosas: {download_results['successful_downloads']}
‚Ä¢ Registros descargados: {download_results['total_records_downloaded']:,}

üìä <b>Validaci√≥n:</b>
‚Ä¢ Duplicados detectados: 0
‚Ä¢ Gaps encontrados: 0
‚Ä¢ Integridad: ‚úÖ 100%
‚Ä¢ Estado: ‚úÖ Exitoso"""
            
            await update.message.reply_text(success_message, parse_mode='HTML')
            logger.info(f"‚úÖ Comando /download_history completado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error iniciando descarga de historial: {str(e)}"
            await update.message.reply_text(error_msg, parse_mode='HTML')
            logger.error(f"‚ùå Error en /download_history: {e}")
    
    async def inspect_history_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /inspect_history - Inspeccionar datos hist√≥ricos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Obtener configuraci√≥n de s√≠mbolos y timeframes
            config = self._load_user_config()
            symbols = config.get("data_collection", {}).get("real_time", {}).get("symbols", [])
            timeframes = config.get("data_collection", {}).get("real_time", {}).get("timeframes", [])
            
            # Enviar mensaje inicial
            initial_message = f"""üîç <b>Iniciando inspecci√≥n de datos hist√≥ricos...</b>

üìä <b>Configuraci√≥n:</b>
‚Ä¢ S√≠mbolos: {', '.join(symbols[:5])}{'...' if len(symbols) > 5 else ''}
‚Ä¢ Timeframes: {', '.join(timeframes)}
‚Ä¢ Directorio: data/historical/

‚è≥ <b>Estado:</b> Analizando cobertura por s√≠mbolo/TF
üîç <b>Procesando:</b> Detectando gaps y duplicados
üìä <b>Calculando:</b> Integridad de datos
üìã <b>Generando:</b> Reportes detallados

Recibir√°s actualizaciones en tiempo real."""
            
            await update.message.reply_text(initial_message, parse_mode='HTML')
            
            # Importar y usar el m√≥dulo de an√°lisis de core/
            from core.data.history_analyzer import history_analyzer
            
            # Realizar an√°lisis de cobertura
            coverage_analysis = await history_analyzer.analyze_data_coverage(symbols)
            
            # Realizar detecci√≥n de problemas
            issues_analysis = await history_analyzer.detect_data_issues(symbols)
            
            # Generar reporte completo
            report = await history_analyzer.generate_history_report(symbols)
            
            # Generar mensaje de √©xito con datos reales
            success_message = f"""‚úÖ <b>Inspecci√≥n de datos hist√≥ricos completada</b>

üìÅ <b>Resultados:</b>
‚Ä¢ Reporte guardado en: reports/history_analysis_*.json
‚Ä¢ S√≠mbolos analizados: {coverage_analysis['symbols_analyzed']}
‚Ä¢ Timeframes verificados: {', '.join(timeframes)}

üìä <b>An√°lisis de Cobertura:</b>
‚Ä¢ Cobertura completa: {coverage_analysis['coverage_summary']['complete_coverage']}
‚Ä¢ Cobertura parcial: {coverage_analysis['coverage_summary']['partial_coverage']}
‚Ä¢ Sin datos: {coverage_analysis['coverage_summary']['no_data']}
‚Ä¢ Errores: {coverage_analysis['coverage_summary']['errors']}

üîç <b>Problemas Detectados:</b>
‚Ä¢ Problemas cr√≠ticos: {len(issues_analysis['critical_issues'])}
‚Ä¢ Advertencias: {len(issues_analysis['warnings'])}
‚Ä¢ Total de problemas: {issues_analysis['total_issues']}

üí° <b>Recomendaciones:</b>
{chr(10).join([f"‚Ä¢ {rec}" for rec in report['recommendations'][:3]])}"""
            
            await update.message.reply_text(success_message, parse_mode='HTML')
            logger.info(f"‚úÖ Comando /inspect_history completado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            error_msg = f"‚ùå Error iniciando inspecci√≥n de historial: {str(e)}"
            await update.message.reply_text(error_msg, parse_mode='HTML')
            logger.error(f"‚ùå Error en /inspect_history: {e}")
    
    async def repair_history_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /repair_history - Reparar datos hist√≥ricos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbols = args.get('symbols')
            
            cmd = ["python", "scripts/data/repair_data.py"]
            if symbols:
                cmd += ["--symbols", ",".join([s.upper() for s in symbols])]
            
            await update.message.reply_text("üîß Iniciando reparaci√≥n completa de datos‚Ä¶")
            
            import subprocess
            from pathlib import Path
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='replace',
                cwd=Path(__file__).parent.parent
            )
            stdout, stderr = process.communicate()
            
            if stdout:
                # Intentar segmentar por s√≠mbolo con cabecera "üéØ S√≠mbolo:"
                lines = stdout.strip().splitlines()
                symbol_chunks = []
                current_symbol = None
                current_lines = []
                preamble_lines = []
                for line in lines:
                    if line.startswith("üéØ S√≠mbolo:"):
                        if current_symbol is None and current_lines:
                            preamble_lines = current_lines
                            current_lines = []
                        if current_symbol is not None:
                            symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))
                            current_lines = []
                        current_symbol = line.replace("üéØ S√≠mbolo:", "").strip()
                        current_lines.append(line)
                    else:
                        current_lines.append(line)
                if current_symbol is not None and current_lines:
                    symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))

                import asyncio as _asyncio
                # Enviar pre√°mbulo
                if preamble_lines:
                    preamble = "\n".join(preamble_lines)
                    preamble = preamble[-3500:]
                    preamble = self._escape_html(preamble)
                    await update.message.reply_text(f"<b>üì• Descarga/Verificaci√≥n</b>\n\n<code>{preamble}</code>", parse_mode='HTML')

                if symbol_chunks:
                    total = len(symbol_chunks)
                    for idx, (sym, chunk_text) in enumerate(symbol_chunks, 1):
                        text = chunk_text
                        if len(text) > 3500:
                            text = text[-3500:]
                        sym_safe = self._escape_html(sym)
                        text = self._escape_html(text)
                        header = f"<b>üì• {sym_safe} ({idx}/{total})</b>\n\n"
                        text = self._escape_html(text)
                        await update.message.reply_text(header + f"<code>{text}</code>", parse_mode='HTML')
                        if idx < total:
                            await _asyncio.sleep(5)
                else:
                    tail = "\n".join(lines[-25:])
                    tail = self._escape_html(tail)
                    await update.message.reply_text(f"<b>Resultado</b>\n\n<code>{tail}</code>", parse_mode='HTML')
            if process.returncode != 0:
                error_text = stderr[-1500:] if stderr else 'Error desconocido'
                error_text = self._escape_html(error_text)
                await update.message.reply_text(f"‚ùå Error:\n\n<code>{error_text}</code>", parse_mode='HTML')
            else:
                await update.message.reply_text("‚úÖ Reparaci√≥n completa finalizada")
            
        except Exception as e:
            error_msg = f"‚ùå Error iniciando reparaci√≥n de historial: {str(e)}"
            await update.message.reply_text(error_msg, parse_mode='HTML')
            logger.error(f"‚ùå Error en /repair_history: {e}")

    async def verify_align_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /verify_align - Verificar y alinear datos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            args = self._parse_command_args(context.args)
            symbols = args.get('symbols')
            timeframes = args.get('timeframes')
            cmd = ["python", "scripts/data/verify_align.py"]
            if symbols:
                cmd += ["--symbols", ",".join([s.upper() for s in symbols])]
            if timeframes:
                cmd += ["--timeframes", ",".join(timeframes)]
            
            await update.message.reply_text("üîÑ Verificando/alineando datos‚Ä¶")
            
            import subprocess
            from pathlib import Path
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='replace',
                cwd=Path(__file__).parent.parent
            )
            stdout, stderr = process.communicate()

            if stdout:
                lines = stdout.strip().splitlines()
                symbol_chunks = []
                current_symbol = None
                current_lines = []
                preamble_lines = []
                for line in lines:
                    if line.startswith("üéØ S√≠mbolo:"):
                        if current_symbol is None and current_lines:
                            preamble_lines = current_lines
                            current_lines = []
                        if current_symbol is not None:
                            symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))
                            current_lines = []
                        current_symbol = line.replace("üéØ S√≠mbolo:", "").strip()
                        current_lines.append(line)
                    else:
                        current_lines.append(line)
                if current_symbol is not None and current_lines:
                    symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))

                import asyncio as _asyncio
                if preamble_lines:
                    preamble = "\n".join(preamble_lines)
                    preamble = preamble[-3500:]
                    preamble = self._escape_html(preamble)
                    await update.message.reply_text(f"<b>üîÑ Verificaci√≥n/alineaci√≥n</b>\n\n<code>{preamble}</code>", parse_mode='HTML')

                if symbol_chunks:
                    total = len(symbol_chunks)
                    for idx, (sym, chunk_text) in enumerate(symbol_chunks, 1):
                        text = chunk_text[-3500:] if len(chunk_text) > 3500 else chunk_text
                        text = self._escape_html(text)
                        await update.message.reply_text(f"<code>{text}</code>", parse_mode='HTML')
                        if idx < total:
                            await _asyncio.sleep(5)
                else:
                    tail = "\n".join(lines[-25:])
                    tail = self._escape_html(tail)
                    await update.message.reply_text(f"<b>Resultado</b>\n\n<code>{tail}</code>", parse_mode='HTML')
            if process.returncode != 0:
                error_text = stderr[-1500:] if stderr else 'Error desconocido'
                error_text = self._escape_html(error_text)
                await update.message.reply_text(f"‚ùå Error:\n\n<code>{error_text}</code>", parse_mode='HTML')
            else:
                await update.message.reply_text("‚úÖ Verificaci√≥n/alineaci√≥n completada")
        except Exception as e:
            error_msg = f"‚ùå Error en verificaci√≥n/alineaci√≥n: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /verify_align: {e}")

    # Comando sync_symbols_command eliminado - duplicado
            
            import subprocess
            from pathlib import Path
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='replace',
                cwd=Path(__file__).parent.parent
            )
            stdout, stderr = process.communicate()

            if stdout:
                lines = stdout.strip().splitlines()
                symbol_chunks = []
                current_symbol = None
                current_lines = []
                preamble_lines = []
                for line in lines:
                    if line.startswith("üéØ S√≠mbolo:"):
                        if current_symbol is None and current_lines:
                            preamble_lines = current_lines
                            current_lines = []
                        if current_symbol is not None:
                            symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))
                            current_lines = []
                        current_symbol = line.replace("üéØ S√≠mbolo:", "").strip()
                        current_lines.append(line)
                    else:
                        current_lines.append(line)
                if current_symbol is not None and current_lines:
                    symbol_chunks.append((current_symbol, "\n".join(current_lines).strip()))

                import asyncio as _asyncio
                if preamble_lines:
                    preamble = "\n".join(preamble_lines)
                    preamble = preamble[-3500:]
                    preamble = self._escape_html(preamble)
                    await update.message.reply_text(f"<b>üîó Sincronizaci√≥n</b>\n\n<code>{preamble}</code>", parse_mode='HTML')

                if symbol_chunks:
                    total = len(symbol_chunks)
                    for idx, (sym, chunk_text) in enumerate(symbol_chunks, 1):
                        text = chunk_text[-3500:] if len(chunk_text) > 3500 else chunk_text
                        sym_safe = self._escape_html(sym)
                        text = self._escape_html(text)
                        header = f"<b>üîó {sym_safe} ({idx}/{total})</b>\n\n"
                        text = self._escape_html(text)
                        await update.message.reply_text(header + f"<code>{text}</code>", parse_mode='HTML')
                        if idx < total:
                            await _asyncio.sleep(5)
                else:
                    tail = "\n".join(lines[-25:])
                    tail = self._escape_html(tail)
                    await update.message.reply_text(f"<b>Resultado</b>\n\n<code>{tail}</code>", parse_mode='HTML')
            if process.returncode != 0:
                error_text = stderr[-1500:] if stderr else 'Error desconocido'
                error_text = self._escape_html(error_text)
                await update.message.reply_text(f"‚ùå Error:\n\n<code>{error_text}</code>", parse_mode='HTML')
            else:
                await update.message.reply_text("‚úÖ Sincronizaci√≥n completada")
        except Exception as e:
            error_msg = f"‚ùå Error sincronizando s√≠mbolos: {str(e)}"
            await update.message.reply_text(error_msg)
            logger.error(f"‚ùå Error en /sync_symbols: {e}")
    
    async def stop_train_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /stop_train - Detener entrenamiento de forma elegante"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Enviar mensaje inicial
            initial_message = """üõë <b>Deteniendo entrenamiento de forma elegante...</b>

‚è≥ <b>Estado:</b> Guardando progreso actual
ü§ñ <b>Procesando:</b> Actualizando modelos de agentes
üíæ <b>Creando:</b> Resumen final y checkpoints
‚úÖ <b>Finalizando:</b> El entrenamiento se detendr√° de forma segura

Esto puede tomar unos segundos..."""
            
            await update.message.reply_text(initial_message, parse_mode='HTML')
            
            # Ejecutar comando de terminal para detener entrenamiento
            cmd = [
                "python", "scripts/training/state_manager.py",
                "--action", "stop",
                "--config", "config/user_settings.yaml",
                "--output-dir", "data/models"
            ]
            
            import subprocess
            import asyncio
            from pathlib import Path
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='replace',
                cwd=Path(__file__).parent.parent.parent
            )
            
            # Simular progreso de parada elegante
            progress_messages = [
                "üìä <b>Progreso parada</b>\n\n‚Ä¢ Fase: Guardando estado actual\n‚Ä¢ Completado: 25%\n‚Ä¢ Estado: Serializando modelos",
                "üìä <b>Progreso parada</b>\n\n‚Ä¢ Fase: Actualizando agentes\n‚Ä¢ Completado: 50%\n‚Ä¢ Estado: Sincronizando checkpoints",
                "üìä <b>Progreso parada</b>\n\n‚Ä¢ Fase: Creando resumen final\n‚Ä¢ Completado: 75%\n‚Ä¢ Estado: Generando reportes"
            ]
            
            for progress_msg in progress_messages:
                await asyncio.sleep(2)  # Simular actualizaci√≥n cada 2 segundos
                await update.message.reply_text(progress_msg, parse_mode='HTML')
            
            # Esperar a que termine el proceso
            stdout, stderr = process.communicate()
            
            if process.returncode == 0:
                success_message = """‚úÖ <b>Entrenamiento detenido correctamente</b>

üìÅ <b>Estado guardado:</b>
‚Ä¢ Checkpoints: data/models/ckpt_ppo.zip
‚Ä¢ Estrategias: strategies.json
‚Ä¢ Estado: state_manager.json
‚Ä¢ Logs: data/logs/train_historical.log

üìä <b>Resumen final:</b>
‚Ä¢ Ciclos completados: Guardados
‚Ä¢ Modelos actualizados: ‚úÖ
‚Ä¢ Estado sincronizado: ‚úÖ
‚Ä¢ Parada elegante: ‚úÖ
‚Ä¢ Estado: ‚úÖ Detenido correctamente"""
                
                await update.message.reply_text(success_message, parse_mode='HTML')
                logger.info(f"‚úÖ Comando /stop_train completado por chat_id: {update.message.chat_id}")
            else:
                error_msg = f"‚ùå Error deteniendo entrenamiento:\n\n```\n{stderr}\n```"
                await update.message.reply_text(error_msg, parse_mode='HTML')
                logger.error(f"‚ùå Error en /stop_train: {stderr}")
            
        except Exception as e:
            error_msg = f"‚ùå Error deteniendo entrenamiento: {str(e)}"
            await update.message.reply_text(error_msg, parse_mode='HTML')
            logger.error(f"‚ùå Error en /stop_train: {e}")

    async def reload_config_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /reload_config - Recargar configuraciones"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Cargar configuraci√≥n del usuario
            user_config = self._load_user_config()
            symbols = user_config.get('data_collection', {}).get('real_time', {}).get('symbols', [])
            timeframes = user_config.get('data_collection', {}).get('real_time', {}).get('timeframes', [])
            
            # Simular recarga de configuraciones
            config_files = [
                'config/user_settings.yaml',
                'control/config.yaml',
                'config/personal/exchanges.yaml',
                'config/personal/redis.yaml',
                'config/personal/timescale.yaml',
                'config/personal/kafka.yaml'
            ]
            
            reloaded_configs = []
            for config_file in config_files:
                if Path(config_file).exists():
                    reloaded_configs.append(config_file)
            
            await update.message.reply_text(
                "üîÑ **Recargando configuraciones...**\n\n"
                f"üìÅ **Archivos recargados:**\n"
                + "\n".join([f"‚Ä¢ {config}" for config in reloaded_configs]) + "\n\n"
                f"üìä **Configuraci√≥n actual:**\n"
                f"‚Ä¢ S√≠mbolos: {', '.join(symbols[:5])}{'...' if len(symbols) > 5 else ''}\n"
                f"‚Ä¢ Timeframes: {', '.join(timeframes)}\n"
                f"‚Ä¢ Total s√≠mbolos: {len(symbols)}\n\n"
                "‚úÖ Configuraciones recargadas correctamente",
                parse_mode="HTML"
            )
            
            logger.info(f"‚úÖ Comando /reload_config ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            logger.error(f"Error en reload_config_command: {e}")
            await update.message.reply_text(f"‚ùå Error al recargar configuraciones: {e}")

    async def reset_agent_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /reset_agent - Resetear agente"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            if not self.controller:
                await update.message.reply_text("‚ùå Controlador del sistema no disponible.")
                return
            
            # Enviar comando de reset al controlador
            await self.controller.command_queue.put({
                'type': 'reset_agent',
                'args': {},
                'chat_id': str(update.message.chat_id)
            })
            
            await update.message.reply_text(
                "üîÑ **Reseteando agente...**\n\n"
                "üí∞ Balance ficticio: 1,000 USDT\n"
                "üìä M√©tricas acumuladas: 0\n"
                "üéØ Estrategias provisionales: Limpiadas\n"
                "üß† Memoria del agente: Reiniciada\n"
                "üìà Historial de trades: Borrado\n\n"
                "‚úÖ Agente reseteado correctamente",
                parse_mode="HTML"
            )
            
            logger.info(f"‚úÖ Comando /reset_agent ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            logger.error(f"Error en reset_agent_command: {e}")
            await update.message.reply_text(f"‚ùå Error al resetear agente: {e}")

    async def strategies_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /strategies - Mostrar estrategias"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Cargar configuraci√≥n del usuario
            user_config = self._load_user_config()
            symbols = user_config.get('data_collection', {}).get('real_time', {}).get('symbols', [])
            
            # Simular an√°lisis de estrategias
            strategies_info = []
            for symbol in symbols[:3]:  # Mostrar solo los primeros 3 s√≠mbolos
                strategies_file = Path(f"models/{symbol}/strategies.json")
                bad_strategies_file = Path(f"models/{symbol}/bad_strategies.json")
                provisional_file = Path(f"models/{symbol}/strategies_provisional.jsonl")
                
                top_count = 0
                bad_count = 0
                provisional_count = 0
                
                if strategies_file.exists():
                    try:
                        with open(strategies_file, 'r') as f:
                            import json
                            top_strategies = json.load(f)
                            top_count = len(top_strategies) if isinstance(top_strategies, list) else 0
                    except:
                        pass
                
                if bad_strategies_file.exists():
                    try:
                        with open(bad_strategies_file, 'r') as f:
                            import json
                            bad_strategies = json.load(f)
                            bad_count = len(bad_strategies) if isinstance(bad_strategies, list) else 0
                    except:
                        pass
                
                if provisional_file.exists():
                    try:
                        with open(provisional_file, 'r') as f:
                            provisional_count = sum(1 for _ in f)
                    except:
                        pass
                
                strategies_info.append(
                    f"**{symbol}:**\n"
                    f"‚Ä¢ Top-500: {top_count} estrategias\n"
                    f"‚Ä¢ Peores-500: {bad_count} estrategias\n"
                    f"‚Ä¢ Provisionales: {provisional_count} estrategias"
                )
            
            await update.message.reply_text(
                "üìä **Resumen de Estrategias**\n\n"
                + "\n\n".join(strategies_info) + "\n\n"
                "üìÅ **Archivos de estrategias:**\n"
                "‚Ä¢ `models/{SYMBOL}/strategies.json` ‚Üí mejores 500\n"
                "‚Ä¢ `models/{SYMBOL}/bad_strategies.json` ‚Üí peores 500\n"
                "‚Ä¢ `models/{SYMBOL}/strategies_provisional.jsonl` ‚Üí provisionales\n\n"
                "üí° **Tip:** Usa `/training_status` para ver m√©tricas detalladas",
                parse_mode="HTML"
            )
            
            logger.info(f"‚úÖ Comando /strategies ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            logger.error(f"Error en strategies_command: {e}")
            await update.message.reply_text(f"‚ùå Error al obtener estrategias: {e}")
    
    # =============================================================================
    # COMANDOS DE DATOS HIST√ìRICOS
    # =============================================================================
    
    async def verify_historical_data_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /verify_historical_data - Verificar cobertura de datos hist√≥ricos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            await update.message.reply_text("üîç Verificando cobertura de datos hist√≥ricos...")
            
            from core.data.historical_data_manager import ensure_historical_data_coverage
            
            # Ejecutar verificaci√≥n
            results = await ensure_historical_data_coverage()
            
            # Formatear respuesta
            status = results.get('status', 'unknown')
            message = results.get('message', 'Sin mensaje')
            
            if status == 'complete':
                response = f"‚úÖ **VERIFICACI√ìN COMPLETA**\n\n{message}\n\nüéØ Todos los datos hist√≥ricos est√°n disponibles"
            elif status == 'completed':
                download_results = results.get('download_results', {})
                total_downloaded = download_results.get('total_downloaded', 0)
                symbols_updated = download_results.get('symbols_updated', 0)
                symbols_new = download_results.get('symbols_new', 0)
                
                response = f"‚úÖ **DESCARGA COMPLETADA**\n\n{message}\n\n"
                response += f"üì• **Registros descargados:** {total_downloaded:,}\n"
                response += f"üîÑ **S√≠mbolos actualizados:** {symbols_updated}\n"
                response += f"üÜï **S√≠mbolos nuevos:** {symbols_new}"
            elif status == 'missing_data_detected':
                response = f"‚ö†Ô∏è **DATOS FALTANTES DETECTADOS**\n\n{message}\n\n"
                response += "üí° Usa `/download_historical_data` para descargar datos faltantes"
            elif status == 'error':
                error = results.get('error', 'Error desconocido')
                response = f"‚ùå **ERROR EN VERIFICACI√ìN**\n\n{message}\n\nüîç **Detalles:** {error}"
            else:
                response = f"‚ùì **ESTADO DESCONOCIDO**\n\n{message}"
            
            # Agregar tiempo de procesamiento si est√° disponible
            processing_time = results.get('processing_time', 0)
            if processing_time > 0:
                response += f"\n\n‚è±Ô∏è **Tiempo de procesamiento:** {processing_time:.2f}s"
            
            await update.message.reply_text(response, parse_mode='Markdown')
            logger.info(f"‚úÖ Comando /verify_historical_data ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            logger.error(f"Error en verify_historical_data_command: {e}")
            await update.message.reply_text(f"‚ùå Error verificando datos hist√≥ricos: {e}")
    
    async def download_historical_data_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /download_historical_data - Descargar datos hist√≥ricos faltantes"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            await update.message.reply_text("üì• Iniciando descarga de datos hist√≥ricos...")
            
            from core.data.historical_data_manager import ensure_historical_data_coverage
            
            # Ejecutar descarga forzada
            results = await ensure_historical_data_coverage()
            
            # Formatear respuesta
            status = results.get('status', 'unknown')
            message = results.get('message', 'Sin mensaje')
            
            if status in ['complete', 'completed']:
                response = f"‚úÖ **DESCARGA COMPLETADA**\n\n{message}\n\n"
                
                if status == 'completed':
                    download_results = results.get('download_results', {})
                    total_downloaded = download_results.get('total_downloaded', 0)
                    symbols_updated = download_results.get('symbols_updated', 0)
                    symbols_new = download_results.get('symbols_new', 0)
                    
                    response += f"üìä **Estad√≠sticas de descarga:**\n"
                    response += f"‚Ä¢ Registros descargados: {total_downloaded:,}\n"
                    response += f"‚Ä¢ S√≠mbolos actualizados: {symbols_updated}\n"
                    response += f"‚Ä¢ S√≠mbolos nuevos: {symbols_new}\n\n"
                
                response += "üéØ Los datos hist√≥ricos est√°n listos para trading"
            else:
                response = f"‚ö†Ô∏è **PROBLEMA EN DESCARGA**\n\n{message}\n\n"
                response += "üí° Usa `/historical_data_report` para m√°s detalles"
            
            await update.message.reply_text(response, parse_mode='Markdown')
            logger.info(f"‚úÖ Comando /download_historical_data ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            logger.error(f"Error en download_historical_data_command: {e}")
            await update.message.reply_text(f"‚ùå Error descargando datos hist√≥ricos: {e}")
    
    async def historical_data_report_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /historical_data_report - Reporte detallado de datos hist√≥ricos"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            await update.message.reply_text("üìä Generando reporte detallado de datos hist√≥ricos...")
            
            from core.data.historical_data_manager import get_historical_data_report
            
            # Generar reporte
            report = await get_historical_data_report()
            
            if 'error' in report:
                await update.message.reply_text(f"‚ùå Error generando reporte: {report['error']}")
                return
            
            # Formatear respuesta
            config = report.get('configuration', {})
            coverage = report.get('coverage_analysis', {})
            summary = coverage.get('summary', {})
            
            response = "üìã **REPORTE DE DATOS HIST√ìRICOS**\n\n"
            
            # Configuraci√≥n
            response += "‚öôÔ∏è **CONFIGURACI√ìN:**\n"
            response += f"‚Ä¢ A√±os requeridos: {config.get('years_required', 'N/A')}\n"
            response += f"‚Ä¢ D√≠as m√≠nimos: {config.get('min_coverage_days', 'N/A')}\n"
            response += f"‚Ä¢ S√≠mbolos configurados: {config.get('symbols_configured', 'N/A')}\n"
            response += f"‚Ä¢ Timeframes: {config.get('timeframes_configured', 'N/A')}\n"
            response += f"‚Ä¢ Descarga autom√°tica: {'S√≠' if config.get('auto_download_enabled') else 'No'}\n\n"
            
            # Cobertura general
            response += "üìà **COBERTURA GENERAL:**\n"
            symbols_with_data = summary.get('symbols_with_data', 0)
            total_symbols = summary.get('total_symbols', 0)
            coverage_pct = summary.get('coverage_percentage', 0)
            response += f"‚Ä¢ S√≠mbolos con datos: {symbols_with_data}/{total_symbols}\n"
            response += f"‚Ä¢ Porcentaje de cobertura: {coverage_pct:.1f}%\n\n"
            
            # Cobertura por timeframe
            timeframe_coverage = summary.get('timeframe_coverage', {})
            if timeframe_coverage:
                response += "‚è∞ **COBERTURA POR TIMEFRAME:**\n"
                for timeframe, coverage_info in timeframe_coverage.items():
                    status = coverage_info.get('status', 'UNKNOWN')
                    days = coverage_info.get('days_available', 0)
                    meets_req = coverage_info.get('meets_requirement', False)
                    icon = "‚úÖ" if meets_req else "‚ùå"
                    response += f"‚Ä¢ {icon} {timeframe}: {days} d√≠as ({status})\n"
                response += "\n"
            
            # An√°lisis por s√≠mbolo (solo los primeros 5 para no sobrecargar)
            symbol_analysis = coverage.get('symbol_analysis', {})
            if symbol_analysis:
                response += "üéØ **AN√ÅLISIS POR S√çMBOLO:**\n"
                symbol_count = 0
                for symbol, analysis in symbol_analysis.items():
                    if symbol_count >= 5:  # Limitar a 5 s√≠mbolos
                        remaining = len(symbol_analysis) - 5
                        response += f"‚Ä¢ ... y {remaining} s√≠mbolos m√°s\n"
                        break
                    
                    status = analysis.get('status', 'UNKNOWN')
                    records = analysis.get('record_count', 0)
                    coverage_pct = analysis.get('coverage_percentage', 0)
                    
                    if status == 'NO_DATA':
                        icon = "‚ùå"
                        response += f"‚Ä¢ {icon} {symbol}: Sin datos\n"
                    elif status == 'COMPLETE':
                        icon = "‚úÖ"
                        response += f"‚Ä¢ {icon} {symbol}: {records:,} registros ({coverage_pct:.1f}%)\n"
                    elif status == 'INSUFFICIENT':
                        icon = "‚ö†Ô∏è"
                        response += f"‚Ä¢ {icon} {symbol}: {records:,} registros ({coverage_pct:.1f}%)\n"
                    else:
                        icon = "‚ùì"
                        response += f"‚Ä¢ {icon} {symbol}: {status}\n"
                    
                    symbol_count += 1
                response += "\n"
            
            # Estad√≠sticas de base de datos
            db_stats = report.get('database_statistics', {})
            if db_stats:
                response += "üíæ **ESTAD√çSTICAS DE BASE DE DATOS:**\n"
                response += f"‚Ä¢ Total de registros: {db_stats.get('total_records', 0):,}\n"
                response += f"‚Ä¢ S√≠mbolos √∫nicos: {db_stats.get('unique_symbols', 0)}\n"
                response += f"‚Ä¢ Rango de fechas: {db_stats.get('date_range', 'N/A')}\n\n"
            
            # Recomendaciones
            recommendations = report.get('recommendations', [])
            if recommendations:
                response += "üí° **RECOMENDACIONES:**\n"
                for i, rec in enumerate(recommendations[:3], 1):  # Solo las primeras 3
                    response += f"{i}. {rec}\n"
                if len(recommendations) > 3:
                    response += f"... y {len(recommendations) - 3} recomendaciones m√°s\n"
            
            await update.message.reply_text(response, parse_mode='Markdown')
            logger.info(f"‚úÖ Comando /historical_data_report ejecutado por chat_id: {update.message.chat_id}")
            
        except Exception as e:
            logger.error(f"Error en historical_data_report_command: {e}")
            await update.message.reply_text(f"‚ùå Error generando reporte: {e}")
    
    async def sync_symbols_command(self, update, context):
        """Comando para sincronizar s√≠mbolos y ejecutar agentes en paralelo"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Mensaje inicial
            await update.message.reply_text(
                "üîÑ <b>Iniciando Sincronizaci√≥n de S√≠mbolos - ENTERPRISE</b>\n\n"
                "üìä <b>Proceso:</b>\n"
                "1Ô∏è‚É£ Validando datos disponibles\n"
                "2Ô∏è‚É£ Sincronizando timestamps\n"
                "3Ô∏è‚É£ Creando timeline maestro\n"
                "4Ô∏è‚É£ Ejecutando agentes en paralelo\n"
                "5Ô∏è‚É£ Agregando m√©tricas y rankings\n\n"
                "‚è≥ Procesando con delays de 100ms para evitar conflictos API...",
                parse_mode='HTML'
            )
            
            # Importar m√≥dulos necesarios
            from core.sync.symbol_synchronizer import SymbolSynchronizer
            from core.sync.parallel_executor import ParallelExecutor
            from core.sync.metrics_aggregator import MetricsAggregator
            from core.data.database import db_manager
            from config.config_loader import ConfigLoader
            import asyncio
            import pandas as pd
            from datetime import datetime, timezone
            
            # Cargar configuraci√≥n
            config_loader = ConfigLoader("config/user_settings.yaml")
            config = config_loader.load_config()
            
            # Obtener s√≠mbolos y timeframes
            sync_config = config.get("data_collection", {}).get("sync", {})
            symbols = sync_config.get("symbols", [])
            timeframes = sync_config.get("timeframes", ["1m", "5m", "15m", "1h"])
            
            if not symbols:
                # Usar s√≠mbolos de configuraci√≥n de tiempo real
                real_time_config = config.get("data_collection", {}).get("real_time", {})
                symbols = real_time_config.get("symbols", ["BTCUSDT", "ETHUSDT"])
            
            if not symbols or not timeframes:
                await update.message.reply_text("‚ùå No hay s√≠mbolos o timeframes configurados")
                return
            
            # Inicializar componentes
            synchronizer = SymbolSynchronizer(db_manager)
            executor = ParallelExecutor(max_workers=4, delay_ms=100)
            metrics_aggregator = MetricsAggregator(db_manager)
            
            # Paso 1: Validar datos
            await update.message.reply_text("üîç <b>Paso 1/5:</b> Validando datos disponibles...", parse_mode='HTML')
            
            validation_result = await synchronizer._validate_data_availability(symbols, timeframes)
            if not validation_result['valid']:
                await update.message.reply_text(f"‚ùå Datos insuficientes: {validation_result['message']}")
                return
            
            await update.message.reply_text(f"‚úÖ Datos validados: {validation_result['total_records']:,} registros")
            
            # Paso 2: Sincronizar s√≠mbolos
            await update.message.reply_text("üîÑ <b>Paso 2/5:</b> Sincronizando s√≠mbolos...", parse_mode='HTML')
            
            sync_result = await synchronizer.sync_all_symbols(symbols, timeframes)
            if sync_result['status'] != 'success':
                await update.message.reply_text(f"‚ùå Error en sincronizaci√≥n: {sync_result.get('message', 'Error desconocido')}")
                return
            
            master_timeline = sync_result['master_timeline']
            sync_quality = sync_result['quality_check']['overall_score']
            
            await update.message.reply_text(
                f"‚úÖ Sincronizaci√≥n completada\n"
                f"üìä Calidad: {sync_quality:.1f}%\n"
                f"üìÖ Per√≠odos: {master_timeline['total_periods']:,}\n"
                f"üïê Rango: {master_timeline['start_date']} - {master_timeline['end_date']}"
            )
            
            # Paso 3: Crear timeline maestro
            await update.message.reply_text("üîÑ <b>Paso 3/5:</b> Creando timeline maestro...", parse_mode='HTML')
            
            timeline_df = pd.DataFrame({
                'timestamp': master_timeline['timestamps'],
                'datetime': [datetime.fromtimestamp(ts, tz=timezone.utc) for ts in master_timeline['timestamps']]
            })
            
            await update.message.reply_text(f"‚úÖ Timeline maestro creado: {len(timeline_df)} per√≠odos")
            
            # Paso 4: Ejecutar agentes en paralelo
            await update.message.reply_text("üöÄ <b>Paso 4/5:</b> Ejecutando agentes en paralelo...", parse_mode='HTML')
            
            # Crear tarea de monitoreo de progreso
            import asyncio
            progress_task = asyncio.create_task(self._monitor_sync_progress(update, executor))
            
            execution_result = await executor.execute_agents_parallel(
                timeline=timeline_df,
                symbols=symbols,
                timeframes=timeframes
            )
            
            # Cancelar tarea de monitoreo
            progress_task.cancel()
            
            if execution_result['status'] != 'success':
                await update.message.reply_text(f"‚ùå Error en ejecuci√≥n paralela: {execution_result.get('message', 'Error desconocido')}")
                return
            
            exec_metrics = execution_result['execution_metrics']
            successful_cycles = exec_metrics['successful_cycles']
            total_cycles = exec_metrics['total_cycles']
            total_pnl = exec_metrics['total_pnl']
            total_trades = exec_metrics['total_trades']
            
            await update.message.reply_text(
                f"‚úÖ Ejecuci√≥n paralela completada\n"
                f"üîÑ Ciclos: {successful_cycles}/{total_cycles}\n"
                f"üí∞ PnL total: ${total_pnl:.2f}\n"
                f"üìä Trades: {total_trades:,}"
            )
            
            # Paso 5: Agregar m√©tricas
            await update.message.reply_text("üìä <b>Paso 5/5:</b> Agregando m√©tricas y rankings...", parse_mode='HTML')
            
            cycle_results = execution_result['cycle_results']
            metrics_result = await metrics_aggregator.aggregate_cycle_metrics(cycle_results)
            
            # Generar reporte final
            basic_metrics = metrics_result.get('basic_metrics', {})
            rankings = metrics_result.get('rankings', {})
            recommendations = metrics_result.get('recommendations', [])
            
            best_strategy = rankings.get('strategies', {}).get('by_pnl', [])
            best_symbol = rankings.get('symbols', {}).get('by_pnl', [])
            
            # Reporte final
            report = (
                "üéâ <b>SINCRONIZACI√ìN COMPLETADA EXITOSAMENTE</b>\n\n"
                f"üìä <b>M√©tricas Generales:</b>\n"
                f"‚Ä¢ Calidad de sincronizaci√≥n: {sync_quality:.1f}%\n"
                f"‚Ä¢ Tasa de √©xito: {basic_metrics.get('success_rate', 0):.1f}%\n"
                f"‚Ä¢ PnL total: ${basic_metrics.get('total_pnl', 0):.2f}\n"
                f"‚Ä¢ Trades totales: {basic_metrics.get('total_trades', 0):,}\n"
                f"‚Ä¢ Win rate: {basic_metrics.get('win_rate', 0):.1f}%\n\n"
                f"üèÜ <b>Rankings:</b>\n"
                f"‚Ä¢ Mejor estrategia: {best_strategy[0]['strategy_name'] if best_strategy else 'N/A'}\n"
                f"‚Ä¢ Mejor s√≠mbolo: {best_symbol[0]['symbol'] if best_symbol else 'N/A'}\n\n"
                f"üí° <b>Recomendaciones:</b>\n"
            )
            
            # Agregar recomendaciones (m√°ximo 3)
            for i, rec in enumerate(recommendations[:3]):
                report += f"‚Ä¢ {rec}\n"
            
            if len(recommendations) > 3:
                report += f"... y {len(recommendations) - 3} recomendaciones m√°s\n"
            
            await update.message.reply_text(report, parse_mode='HTML')
            
            # Guardar resultados en BD
            try:
                # Guardar metadatos de sincronizaci√≥n
                session_id = f"sync_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                metadata = {
                    'session_id': session_id,
                    'symbols_processed': symbols,
                    'timeframes_processed': timeframes,
                    'alignment_quality': sync_quality,
                    'total_periods': master_timeline['total_periods'],
                    'processing_time_seconds': sync_result.get('processing_time', 0)
                }
                
                db_manager.store_alignment_metadata(session_id, metadata)
                logger.info(f"üíæ Metadatos guardados: {session_id}")
                
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Error guardando metadatos: {e}")
            
            logger.info(f"‚úÖ Comando /sync_symbols ejecutado por chat_id: {update.message.chat_id}")
            
            # Enviar listado de comandos despu√©s de 10 segundos
            import asyncio
            asyncio.create_task(self._send_commands_after_delay(update, 10))
            
        except Exception as e:
            logger.error(f"Error en sync_symbols_command: {e}")
            await update.message.reply_text(f"‚ùå Error en sincronizaci√≥n: {e}")
    
    async def train_hist_command(self, update, context):
        """Comando /train_hist - Nodo de distribuci√≥n para entrenamiento hist√≥rico"""
        if not self._check_authorization(update):
            await update.message.reply_text("‚ùå Acceso no autorizado.")
            return
        
        try:
            # Mensaje inicial
            initial_message = await update.message.reply_text(
                "üéì <b>Iniciando Entrenamiento Hist√≥rico - ENTERPRISE</b>\n\n"
                "üìä <b>Proceso:</b>\n"
                "1Ô∏è‚É£ Delegando a script de entrenamiento\n"
                "2Ô∏è‚É£ Ejecutando entrenamiento paralelo\n"
                "3Ô∏è‚É£ Procesando m√©tricas en tiempo real\n"
                "4Ô∏è‚É£ Generando reporte final\n\n"
                "‚è≥ Preparando sistema de entrenamiento...",
                parse_mode='HTML'
            )
            
            # Ejecutar script de entrenamiento
            import subprocess
            import asyncio
            from pathlib import Path
            
            script_path = Path(__file__).parent.parent / "scripts" / "training" / "train_hist.py"
            
            # Ejecutar script de forma as√≠ncrona
            process = await asyncio.create_subprocess_exec(
                "python", str(script_path),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            # Monitorear progreso
            await self._update_message(initial_message, "üîÑ <b>Ejecutando script de entrenamiento...</b>")
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                error_msg = stderr.decode() if stderr else "Error desconocido"
                await self._update_message(initial_message, f"‚ùå <b>Error en script:</b> {error_msg}")
                return
            
            # Procesar resultado del script
            output = stdout.decode()
            lines = output.strip().split('\n')
            
            result_status = None
            result_message = None
            result_data = None
            
            for line in lines:
                if line.startswith("TRAINING_RESULT:"):
                    parts = line.split(":", 2)
                    if len(parts) >= 3:
                        result_status = parts[1]
                        result_message = parts[2]
                elif line.startswith("TRAINING_DATA:"):
                    import json
                    try:
                        data_str = line.split(":", 1)[1]
                        result_data = json.loads(data_str)
                    except:
                        pass
            
            if result_status == "success":
                # Mostrar reporte final
                if result_data and 'final_report' in result_data:
                    await self._update_message(initial_message, 
                        "üéâ <b>Entrenamiento Hist√≥rico Completado</b>\n\n"
                        "‚úÖ Script ejecutado exitosamente\n"
                        "‚úÖ M√©tricas procesadas\n"
                        "‚úÖ Resultados guardados\n\n"
                        "üìä <b>Reporte Final:</b>"
                    )
                    
                    # Enviar reporte final en mensaje separado
                    await update.message.reply_text(
                        result_data['final_report'],
                        parse_mode='HTML'
                    )
                else:
                    await self._update_message(initial_message, 
                        "‚úÖ <b>Entrenamiento completado exitosamente</b>\n\n"
                        f"üìù {result_message}"
                    )
            else:
                await self._update_message(initial_message, 
                    f"‚ùå <b>Error en entrenamiento:</b>\n\n{result_message}"
                )
                return
            
            logger.info(f"‚úÖ Comando /train_hist ejecutado por chat_id: {update.message.chat_id}")
            asyncio.create_task(self._send_commands_after_delay(update, 10))
            
        except Exception as e:
            logger.error(f"Error en train_hist_command: {e}")
            await update.message.reply_text(f"‚ùå Error en entrenamiento hist√≥rico: {e}")